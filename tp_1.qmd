---
title: "{{< fa flask >}} **Econom√©trie Appliqu√©e**"
title-block-banner: imgs/apples.png
subtitle: "Des üçè sur {{< fa brands r-project >}} !"
toc: true
toc-title: üìö Table des mati√®res
lang: fr
number-sections: true
author:
  - name: "*Corentin Ducloux*"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
  - name: "*Guillaume Devant*"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
date: today
date-format: short
include-in-header: 
    - text: | 
        <link href='https://fonts.googleapis.com/css?family=Fira Code' rel='stylesheet'>
format:
    html:
        theme: simplex
        monofont: "Fira Code"
        fontsize: 1em
        embed-resources: true
        html-math-method: mathjax
        code-fold: true 
        anchor-sections: true
        smooth-scroll: true
        citations-hover: true
        footnotes-hover: true
        link-external-icon: true
        link-external-newwindow: true
code-block-bg: "#F1F3F5"
code-block-border-left: "#d9230f"
license: "CC BY-SA"
bibliography: references.bib
crossref:
    eq-prefix: √©quation
    tbl-prefix: Tableau
editor_options: 
    chunk_output_type: console
---

```{css, echo=FALSE}
.img-block {
    margin: auto;
    width: 85%;
    padding: 10px;
    text-align: center;
}
.img-block img {
    display: inline-block;
    margin: auto;
    max-width: 100%;
}
.title {
    color: white;
}
.subtitle {
    color: white;
}
```

***

:::{.img-block}
<br>
<img src="imgs/MECEN_logo.png" alt="MECEN Logo" style="width: 30%;">
<img src="imgs/UT_logo.jpg" alt="UT Logo" style="width: 45%;">

:::

***

```{r}
#| label: functions
#| echo: false

makestars <- function(pvalues) {
    return(
        dplyr::case_when(
            pvalues < 0.001 ~ "$***$",
            pvalues < 0.05 ~ "$**$",
            pvalues < 0.1 ~ "$*$",
            .default = ""
        )
    )
}


gtgazer <- function(model, n_coef = 4, coefnames, description, title, bg_color) {
    if (class(model) %in% c("translogEst")) {
        coefficients <- summary(model)$coefTable[1:n_coef, 1]
        std_values <- summary(model)$coefTable[1:n_coef, 2]
        pvalues <- summary(model)$coefTable[1:n_coef, 4]
        signif <- makestars(pvalues)
        r2 <- round(summary(model)$r2, 3)
        adj_r2 <- round(summary(model)$r2bar, 3)
        n <- summary(model)$nObs
        dep_variable <- summary(model)$yName
    } else if (class(model) %in% c("quadFuncEst", "translogCostEst")) {
        coefficients <- summary(model$est)$coefficients[, 1]
        std_values <- summary(model$est)$coefficients[, 2]
        pvalues <- summary(model$est)$coefficients[, 4]
        signif <- makestars(pvalues)
        r2 <- round(model$r2, 3)
        adj_r2 <- round(model$r2bar, 3)
        n <- model$nObs
        dep_variable <- ifelse(class(model) == "quadFuncEst", model$yName, model$cName)
    } else if (class(model) == "lm") {
        coefficients <- summary(model)$coefficients[, 1]
        std_values <- summary(model)$coefficients[, 2]
        pvalues <- summary(model)$coefficients[, 4]
        signif <- makestars(pvalues)
        r2 <- round(summary(model)$r.squared, 3)
        adj_r2 <- round(summary(model)$adj.r.squared, 3)
        n <- nobs(model)
        dep_variable <- "qOut"
    }

    coefnames <- coefnames
    description <- description
    reg_results <- data.frame(cbind(coefnames, description, coefficients, std_values, pvalues, signif)) |>
        tibble() |>
        mutate(across(c(coefficients, std_values, pvalues), as.numeric))

    table <- reg_results |>
        gt(rowname_col = "coefnames") |>
        cols_label(
            description = md("**Description**"),
            coefficients = md("**Coefficients**"),
            std_values = md("**Ecart Type**"),
            pvalues = md("**Pvalues**"),
            signif = md("**Significativit√©**")
        ) |>
        fmt_markdown(columns = c(coefnames, signif, description)) |>
        fmt_number(
            columns = c(coefficients, pvalues),
            decimals = 3,
            drop_trailing_zeros = TRUE
        ) |>
        fmt(columns = std_values, fns = function(std) {
            paste("+/-", round(std, 3))
        }) |>
        tab_footnote(footnote = md(sprintf("*Observations* : %s", n))) |>
        tab_footnote(footnote = md("***")) |>
        tab_footnote(footnote = md(glue::glue("$R^2=$ {r2}"))) |>
        tab_footnote(footnote = md(glue::glue("$R^2_{{adj}}=$ {adj_r2}"))) |>
        tab_header(
            title = md(title),
            subtitle = md(glue::glue("Variable d√©pendante : {dep_variable}"))
        ) |>
        tab_options(
            table.background.color = bg_color
        )

    return(table)
}
```

## Imports et configuration

:::{.callout-note}

Tout au long de ce projet, nous utiliserons l'approche [`tidy`](https://www.tidyverse.org/) d√©velopp√©e par @wickham2014 plut√¥t que l'approche `base R` pour manipuler nos donn√©es.

:::

```{r}
#| label: lib_imports
#| warning: false
#| code-fold: false
library(ggplot2)
library(dplyr)
library(tidyr)
library(gt)
library(tibble)
library(patchwork)
library(FactoMineR)
library(factoextra)
library(ggtext)
library(micEcon)
library(micEconIndex)
library(micEconCES)
library(frontier)
library(ranger)
library(tuneRanger)
library(mlr)
library(rsample)
library(forcats)
library(performance)
```

```{r}
#| label: colors
#| echo: false
bg_color <- "#FCFCFC"
alpha <- 0.7
```

```{r}
#| label: theming
#| echo: false
theme_set(theme_minimal())
thematic::thematic_on(bg = "#FCFCFC", fg = "black", accent = "purple", font = "PT Sans")
```

## Description des donn√©es

Le jeu de donn√©es `appleProdFr86` utilis√© dans le papier d'√©conom√©trie de @ivaldi1996 comprend des donn√©es transversales de production de **140** producteurs de pommes fran√ßais datant de l‚Äôann√©e 1986. 

```{r}
#| label: data_import
#| code-fold: false
apples <- readxl::read_excel("data/appleProdFr86.xlsx")
```

| Colonnes    | Description                                                                                              |
|-------------|----------------------------------------------------------------------------------------------------------|
| `vCap`      | Co√ªts associ√©s au **capital** *(foncier compris)*.                                                       |
| `vLab`      | Co√ªts associ√©s au **travail** *(y compris la r√©mun√©ration du travail familial non r√©mun√©r√©)*.            |
| `vMat`      | Co√ªts des **mati√®res interm√©diaires** *(plantations, engrais, pesticides, carburant, etc)*.              |
| `qApples`   | Indice de quantit√© des pommes produites.                                                                 |
| `qOtherOut` | Indice de quantit√© de tous les autres outputs.                                                           |
| `qOut`      | Indice de quantit√© de toute la production $\Rightarrow 580000 \cdot (\text{qApples} + \text{qOtherOut})$ |
| `pCap`      | Indice des prix du **capital**.                                                                           |
| `pLab`      | Indice des prix du **travail**.                                                                           |
| `pMat`      | Indice des prix des **mati√®res interm√©diaires**.                                                          |
| `pOut`      | Indice des prix de la production globale.                                                                 |
| `adv`       | Distingue les producteurs qui sont conseill√©s par des laboratoires d'agronomie.                           |

: Descriptif des colonnes {.hover}

### Tableau descriptif {#sec-desc-table}

> Ce tableau descriptif retrace les 10 premi√®res observations et l'ensemble des variables associ√©es dans le *dataset*.

```{r}
#| label: descriptive table
#| echo: false
apples |>
    head(n = 10) |>
    gt() |>
    tab_header(
        title = md("**Producteurs de pommes üçé**"),
        subtitle = md("*140 producteurs* üá´üá∑ *(1986)*")
    ) |>
    tab_source_note(
        source_note = md(
            "`Source`: *Ivaldi et al. (1996)*"
        )
    ) |>
    tab_spanner(
        label = "Costs",
        columns = c("vCap", "vLab", "vMat")
    ) |>
    tab_spanner(
        label = "Price Index",
        columns = c("pCap", "pLab", "pMat", "pOut")
    ) |>
    tab_spanner(
        label = "Quantity Index",
        columns = c("qApples", "qOtherOut", "qOut")
    ) |>
    tab_spanner(
        label = "Factor Quantities",
        columns = c("qCap", "qLab", "qMat")
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "lavenderblush")
        ),
        location = cells_body(columns = c(vCap, vLab, vMat))
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "ivory")
        ),
        location = cells_body(columns = c(qApples, qOtherOut, qOut))
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "aliceblue")
        ),
        location = cells_body(columns = c(pCap, pLab, pMat, pOut))
    ) |>
    fmt_number(suffixing = TRUE, n_sigfi = 2) |>
    text_case_match(
        "1.0" ~ fontawesome::fa("check"),
        "0" ~ fontawesome::fa("xmark"),
        .locations = cells_body(columns = adv)
    ) |>
    cols_label(
        N = md("$N$"),
        vCap = md("$v_{Cap}$"),
        vLab = md("$v_{Lab}$"),
        vMat = md("$v_{Mat}$"),
        qApples = md("$q_{Apples}$"),
        qOtherOut = md("$q_{OtherOut}$"),
        qOut = md("$q_{Out}$"),
        pCap = md("$p_{Cap}$"),
        pLab = md("$p_{Lab}$"),
        pMat = md("$p_{Mat}$"),
        pOut = md("$p_{Out}$"),
        adv = md("$adv$"),
        qCap = md("$q_{Cap}$"),
        qLab = md("$q_{Lab}$"),
        qMat = md("$q_{Mat}$")
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

## Statistiques descriptives

### Productivit√© moyenne des facteurs de production {#sec-ap-prod}

La productivit√© moyenne ($AP =$ **Average Product**) consiste √† diviser la quantit√© totale d'output par la quantit√© totale de facteur utilis√© *(input)* dans le processus de production.

Imaginons que les unit√©s d'output sont des tonnes. Pour chaque input, cela revient en fait √† expliquer combien de tonnes sont produites **en moyenne** par unit√© de capital, de travail et de mati√®res interm√©diaires en 1986 pour chaque producteur de pommes.

Nous obtenons alors respectivement :

- $AP_{Cap} = \frac{q_{Out}}{q_{Cap}}$

- $AP_{Lab} = \frac{q_{Out}}{q_{Lab}}$

- $AP_{Mat} = \frac{q_{Out}}{q_{Mat}}$


```{r}
#| label: productivites
#| code-fold: false
apples <- apples |> mutate(
    AP_Cap = qOut / qCap,
    AP_Lab = qOut / qLab,
    AP_Mat = qOut / qMat
)
```

```{r}
#| label: table_AP
#| echo: false
tibble_AP_Cap <- apples |>
    summarise(min = min(AP_Cap), mean = mean(AP_Cap), max = max(AP_Cap), std = sd(AP_Cap)) |>
    add_column(type = "$AP_{Cap}$", .before = "min")
tibble_AP_Lab <- apples |>
    summarise(min = min(AP_Lab), mean = mean(AP_Lab), max = max(AP_Lab), std = sd(AP_Lab)) |>
    add_column(type = "$AP_{Lab}$", .before = "min")
tibble_AP_Mat <- apples |>
    summarise(min = min(AP_Mat), mean = mean(AP_Mat), max = max(AP_Mat), std = sd(AP_Mat)) |>
    add_column(type = "$AP_{Mat}$", .before = "min")

AP_table <- bind_rows(tibble_AP_Cap, tibble_AP_Lab, tibble_AP_Mat)

AP_table |>
    gt() |>
    fmt_markdown(columns = type) |>
    fmt_number(columns = c(-type)) |>
    tab_header(
        title = md("**Productivit√© Moyenne par Facteur üìã**"),
        subtitle = md("*Capital --- Travail --- Mat√©riaux*")
    ) |>
    cols_label(
        min = md("$\\min$"),
        mean = md("$\\mu$"),
        max = md("$\\max$"),
        std = md("$\\sigma^2$"),
        type = ""
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

Ce tableau, en plus des visualisations qui vont suivre, permet d'√©tablir que les productivit√©s moyennes par facteur sont **tr√®s diff√©rentes selon les producteurs**. De plus, on s'aper√ßoit aussi qu'investir dans un facteur particulier peut √™tre plus int√©ressant qu'un autre. 

C'est particuli√®rement vrai pour le facteur `Mat` avec une productivit√© moyenne minimale de **8.22** unit√©s d'output pour une unit√© de mat√©riaux et jusqu'√† **301.43** unit√©s d'output pour une unit√© de mat√©riaux.

```{r}
#| label: AP_plots
#| echo: false
#| fig-align: center
apples |>
    ggplot() +
    aes(x = AP_Cap) +
    geom_histogram(binwidth = 1.25, fill = "darkgreen", alpha = alpha) +
    labs(title = "Productivit√© Moyenne du Capital", subtitle = "Pour une unit√© de capital, combien d'unit√©s d'output sont produits ?", x = "", y = "Fr√©quence")

apples |>
    ggplot() +
    aes(x = AP_Lab) +
    geom_histogram(binwidth = 0.75, fill = "orange", alpha = alpha) +
    labs(title = "Productivit√© Moyenne du Travail", subtitle = "Pour une unit√© de travail, combien d'unit√©s d'output sont produits ?", x = "", y = "Fr√©quence")

apples |>
    ggplot() +
    aes(x = AP_Mat) +
    geom_histogram(binwidth = 1.5, fill = "darkorchid", alpha = alpha) +
    labs(title = "Productivit√© Moyenne des mat√©riaux", subtitle = "Pour une unit√© de mat√©riaux, combien d'unit√©s d'output sont produits ?", x = "", y = "Fr√©quence")
```

### Corr√©lations entre les quantit√©s des 3 facteurs de production

```{r}
#| label: q_matrix
#| echo: false
apples |>
    select(qCap, qLab, qMat) |>
    cor() |>
    round(2) |>
    data.frame() |>
    gt() |>
    tab_header(title = md("**Matrice de corr√©lation**")) |>
    cols_add(type = c("$q_{Cap}$", "$q_{Lab}$", "$q_{Mat}$")) |>
    cols_move_to_start(columns = type) |>
    fmt_markdown(type) |>
    cols_label(
        type = "",
        qCap = md("$q_{Cap}$"),
        qLab = md("$q_{Lab}$"),
        qMat = md("$q_{Mat}$"),
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

- Les quantit√©s des 3 facteurs de production sont toutes corr√©l√©es positivement.

- On s'aper√ßoit que la corr√©lation **positive** la plus importante est entre $q_{Lab}$ et $q_{Mat}$ $\Rightarrow$ cela implique que lorsque la quantit√© de travail augmente, la quantit√© de mat√©riaux a tendance √† augmenter dans un niveau tr√®s similaire, et *vice versa*.

### Corr√©lations entre les productivit√©s moyennes

Essayons maintenant de comprendre comment les productivit√©s moyennes individuelles sont corr√©l√©es :

```{r}
#| label: ap_matrix
#| echo: false
apples |>
    select(starts_with("AP")) |>
    cor() |>
    round(2) |>
    data.frame() |>
    gt() |>
    tab_header(title = md("**Matrice de corr√©lation**")) |>
    cols_add(type = c("$AP_{Cap}$", "$AP_{Lab}$", "$AP_{Mat}$")) |>
    cols_move_to_start(columns = type) |>
    fmt_markdown(type) |>
    cols_label(
        type = "",
        AP_Cap = md("$AP_{Cap}$"),
        AP_Lab = md("$AP_{Lab}$"),
        AP_Mat = md("$AP_{Mat}$")
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

- Ces r√©sultats nous sugg√®rent l'existence de relations positives entre les productivit√©s moyennes des diff√©rents facteurs de production dans le processus de production. 

- Ici, une augmentation de la productivit√© moyenne du travail peut √™tre associ√©e √† une augmentation **significative** de la productivit√© moyenne des mat√©riaux, ce qui peut √™tre d√ª √† des facteurs tels que des processus de production plus efficaces ou une meilleure utilisation des ressources de la part du producteur de pommes.

***


```{r}
#| label: prod_plots
#| echo: false
#| fig-align: center
CL <- apples |>
    ggplot() +
    aes(x = AP_Cap, y = AP_Lab) +
    geom_point(colour = "slategray", alpha = alpha) +
    labs(x = expression(AP[Cap]), y = expression(AP[Lab]))
ML <- apples |>
    ggplot() +
    aes(x = AP_Mat, y = AP_Lab) +
    geom_point(colour = "gray", alpha = alpha) +
    labs(x = expression(AP[Mat]), y = expression(AP[Lab]))
CM <- apples |>
    ggplot() +
    aes(x = AP_Cap, y = AP_Mat) +
    geom_point(colour = "gray21", alpha = alpha) +
    labs(x = expression(AP[Cap]), y = expression(AP[Mat]))

prod_plots <- (CL + ML) / CM

prod_plots + plot_annotation(
    title = "Croisement des productivit√©s moyennes",
    subtitle = "Quelles sont les relations existantes entre les diff√©rentes productivit√©s moyennes ?",
    caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
)
```

::: {.callout-note}

Les repr√©sentations des productivit√©s moyennes $AP_{Cap}$, $AP_{Lab}$ et $AP_{Mat}$ par rapport √† l'output $q_{Out}$ peuvent aussi √™tre tr√®s utiles pour comprendre les relations entre la production totale et l'utilisation des diff√©rents facteurs de production.

:::

```{r}
#| label: qout_plots
#| echo: false
#| fig-align: center
QC <- apples |>
    ggplot() +
    aes(y = qOut, x = AP_Cap) +
    geom_point(colour = "darkgreen", alpha = alpha) +
    labs(x = expression(AP[Cap]), y = "")
QL <- apples |>
    ggplot() +
    aes(y = qOut, x = AP_Lab) +
    geom_point(colour = "orange", alpha = alpha) +
    labs(x = expression(AP[Lab]), y = "")
QM <- apples |>
    ggplot() +
    aes(y = qOut, x = AP_Mat) +
    geom_point(colour = "darkorchid", alpha = alpha) +
    labs(x = expression(AP[Mat]), y = "")

qOut_prod_plots <- (QC + QL) / QM

qOut_prod_plots + plot_annotation(
    title = "Productivit√© moyenne par rapport √† l'output total",
    subtitle = "Quelles sont les relations existantes entre les productivit√©s moyennes des inputs et de l'output ?",
    caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
)
```

- Les valeurs extr√™mes dans ces nuages de points nous permettent de distinguer ais√©ment les producteurs *efficaces* et *inefficaces* dans l'utilisation des ressources.

### Indices de Paasche, Laspeyres et Fisher

Les productivit√©s moyennes nous donnent une indication facteur par facteur, mais elles ne nous donnent pas n√©cessairement d'information **globale**. Dans ce cadre, on peut alors se demander comment agr√©ger des quantit√©s avec une r√®gle *ad hoc* en un indice synth√©tique.

**3 Indices principaux existent**

::: {.callout-tip}

## Indice de *Paasche*

$$
\text{Paasche}_{index} = \frac{(v_{Cap} + v_{Lab} + v_{Mat})}{{\bar{q}_{Cap}}\cdot p_{Cap} + \bar{q}_{Lab}\cdot p_{Lab} + \bar{q}_{Mat} \cdot p_{Mat}}
$$

:::

::: {.callout-tip}

## Indice de *Laspeyres*

$$
\text{Laspeyres}_{index} = \frac{(q_{Cap} \cdot \bar{p}_{Cap} + q_{Lab} \cdot \bar{p}_{Lab} + q_{Mat} \cdot \bar{p}_{Mat})}{(\bar{q}_{Cap}\cdot \bar{p}_{Cap}+\bar{q}_{Lab}\cdot \bar{p}_{Lab}+\bar{q}_{Mat}\cdot \bar{p}_{Mat})}
$$

:::

::: {.callout-tip}

## Indice de *Fisher*

$$
\text{Fisher}_{index} = \sqrt{\text{Paasche}_{index} \cdot \text{Laspeyres}_{index}}
$$

:::

De plus, la fonction `quantityIndex` du package `micEconIndex` a l'int√©r√™t de facilement int√©grer les calculs de chaque indice *(Voir ci-dessous)*.

```{r}
#| label: q_index
#| code-fold: false
apples <- apples |> mutate(
    L_Index = quantityIndex(
        prices = c("pCap", "pLab", "pMat"),
        quantities = c("qCap", "qLab", "qMat"),
        data = apples,
        method = "Laspeyres"
    ),
    P_Index = quantityIndex(
        prices = c("pCap", "pLab", "pMat"),
        quantities = c("qCap", "qLab", "qMat"),
        data = apples,
        method = "Paasche"
    ),
    F_Index = quantityIndex(
        prices = c("pCap", "pLab", "pMat"),
        quantities = c("qCap", "qLab", "qMat"),
        data = apples,
        method = "Fisher"
    )
)
```

```{r}
#| label: q_index_plots
#| echo: false
#| warning: false
#| fig-align: center
apples |>
    ggplot() +
    aes(x = P_Index, y = L_Index) +
    geom_point() +
    geom_smooth(method = lm, se = FALSE) +
    labs(
        x = "Paasche Index",
        y = "Laspeyres Index",
        title = "Relation entre l'indice de Paasche & de Laspeyres"
    ) +
    theme(legend.position = "None")
```

D'apr√®s cette visualisation on peut conclure que faire le choix de l'indice de *Paasche* ou de *Laspeyres* revient sensiblement √† la m√™me interpr√©tation. 

*Note* : Etant donn√© que l'indice de *Fisher* est une moyenne g√©om√©trique des deux indices, il n'est pas non plus n√©cessaire de le repr√©senter puisque la relation lin√©aire entre les deux indices sera presque parfaite dans ce cas.

***

```{r}
#| label: f_index_matrix
#| echo: false
apples |>
    select(AP_Cap, AP_Lab, AP_Mat, F_Index) |>
    cor() |>
    round(2) |>
    data.frame() |>
    gt() |>
    tab_header(md("**Matrice de corr√©lation**")) |>
    tab_style(
        style = list(
            cell_fill(color = "gray95")
        ),
        locations = cells_body(columns = F_Index)
    ) |>
    cols_add(
        type = c("$AP_{Cap}$", "$AP_{Lab}$", "$AP_{Mat}$", "$\\text{Fisher}_{index}$")
    ) |>
    cols_move_to_start(columns = type) |>
    fmt_markdown(type) |>
    cols_label(
        type = "",
        AP_Cap = md("$AP_{Cap}$"),
        AP_Lab = md("$AP_{Lab}$"),
        AP_Mat = md("$AP_{Mat}$"),
        F_Index = md("$\\text{Fisher}_{index}$")
    ) |>
    tab_style(
        style = cell_fill(color = "gray95"),
        locations = cells_body(rows = c(4))
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

- Ces r√©sultats sugg√®rent que l'indice de *Fisher* n'est pas fortement corr√©l√© avec les productivit√©s moyennes individuelles des facteurs de production.

### Productivit√© globale des facteurs

- Dans la section pr√©c√©dente, nous avons montr√© que les indices donnaient sensiblement les m√™mes r√©sultats. Nous avons n√©anmoins choisi en tant qu'indice de productivit√© globale des facteurs l'indice de *Fisher*, √©tant donn√© qu'il est une moyenne g√©om√©trique de l'indice de *Paasche* et de celui de *Laspeyres*.

```{r}
#| label: f_index_hist
#| echo: false
#| fig-align: center
apples |>
    ggplot() +
    aes(x = F_Index) +
    geom_histogram(binwidth = 0.25, fill = "darkred", alpha = 0.7) +
    labs(title = "Productivit√© globale (Indice de Fisher)", x = "Valeur de l'indice", y = "Fr√©quence")
```

- De mani√®re int√©ressante, contrairement aux histogrammes des productivit√©s moyennes de la @sec-ap-prod, la plupart des valeurs que prend l'indice de *Fisher* sont plus concentr√©es.

```{r}
#| label: f_index_plots
#| echo: false
#| fig-align: center
apples |>
    ggplot() +
    aes(y = qOut, x = F_Index) +
    geom_point(colour = "darkorchid", alpha = alpha) +
    labs(title = "Relation entre l'indice de productivit√© globale des facteurs et l'output", y = "", x = "Indice de Fisher")
```

::: {.callout-note}

La variable dichotomique `adv` pr√©sente dans notre *dataset* est d√©finie par :

$$
adv = 
\begin{cases}
0 \text{ si le producteur n'est pas conseill√©}\\
1 \text{ si le producteur est conseill√©}
\end{cases}
$$

On pourrait penser que les producteurs qui ont √©t√© conseill√©s par des laboratoires d'agronomie ont un indice de productivit√© globale plus important que ceux qui ne l'ont pas √©t√©. 

**V√©rifions-le graphiquement et statistiquement**

:::

```{r}
#| label: advice_boxplot
#| echo: false
apples <- apples |> mutate(
    adv_chr = case_when(
        adv == 0 ~ "No advice",
        adv == 1 ~ "Advice",
    )
)

apples |>
    ggplot() +
    aes(y = F_Index, x = adv_chr, fill = adv_chr) +
    geom_boxplot() +
    labs(title = "Productivit√© globale en fonction du conseil ou non d'un laboratoire", x = "", y = "") +
    theme(legend.position = "None")

apples_grouped <- apples |>
    select(adv_chr, F_Index) |>
    group_by(adv_chr) |>
    summarise(mean = mean(F_Index))

mean_advice <- apples_grouped |>
    slice(1) |>
    pull()

mean_no_advice <- apples_grouped |>
    slice(2) |>
    pull()
```

- En moyenne, il semble ne pas y avoir de diff√©rence de productivit√© globale lorsque le producteur est conseill√©. En effet, la productivit√© moyenne avec conseil est √©gale √† `r round(mean_advice,2)` tandis que la productivit√© moyenne sans conseil est quant √† elle √©gale √† `r round(mean_no_advice,2)`.

On peut aussi s'assurer que les moyennes sont significativement diff√©rentes en faisant un test de *Student* bilat√©ral :

$$
\begin{cases}
H_0:\mu_{advice} =\mu_{no\_advice}\\
H_1:\mu_{advice} \neq\mu_{no\_advice}
\end{cases}
$$


```{r}
#| label: advice_ttest
#| echo: false
advice <- apples |>
    select(adv_chr, F_Index) |>
    filter(adv_chr == "Advice") |>
    pull()

no_advice <- apples |>
    select(adv_chr, F_Index) |>
    filter(adv_chr == "No advice") |>
    pull()

t_test <- t.test(advice, no_advice, var.equal = F)
pval_t_test <- t_test$p.value
```

$\Rightarrow$ Au risque $\alpha = 5\%$, la $p-value =$ `r  round(pval_t_test,2)` $> 0.05$, **on conserve donc l'hypoth√®se nulle $H_0$, c'est √† dire qu'il n'y a pas de diff√©rence significative dans les productivit√©s globales quand le producteur est conseill√©/ qu'il ne l'est pas.**


## Analyse exploratoire

```{r}
#| label: pca_biplot
#| echo: false
#| fig-align: center
apples_pca <- apples[-c(96, 129), ] |> select(-c(N, adv_chr))

# On retire les individus 96 et 129 de l'ACP

acp <- PCA(apples_pca, graph = FALSE)

fviz_screeplot(
    acp,
    ylab = "",
    barfill = "royalblue",
    barcolor = "royalblue"
)

contrib_ax_1 <- fviz_contrib(
    acp,
    choice = "var",
    axes = 1,
    fill = "royalblue",
    color = "royalblue"
)

contrib_ax_2 <- fviz_contrib(
    acp,
    choice = "var",
    axes = 2,
    fill = "royalblue",
    color = "royalblue"
)

contrib_ax_1 + contrib_ax_2

fviz_pca_biplot(acp,
    repel = TRUE,
    title = "ACP - Biplot",
    label = "var",
    col.var = "royalblue",
    col.ind = "orange",
    axes = c(1, 2)
)
```

- **Axe 1** $\Rightarrow$ Combinaison de variables : synth√©thise les indices de *Fisher*, *Paasche* et *Laspeyres*, ainsi que les quantit√©s et les co√ªts des 3 facteurs de production.

- **Axe 2** $\Rightarrow$ Productivit√©s moyennes.

**TODO : Customiser les couleurs de contributions et des inerties et tout**

```{r}
#| label: norm_density
#| echo: false
#| fig-align: center
# https://r-charts.com/distribution/histogram-density-ggplot2/
apples |>
    ggplot(aes(x = log(qOut))) +
    geom_histogram(aes(y = after_stat(density)),
        alpha = 0.6,
        bins = 25,
        fill = "royalblue",
        color = "royalblue"
    ) +
    labs(
        x = "log()",
        y = "Fr√©quence"
    ) +
    theme(plot.title = element_markdown(face = "bold", size = 15)) +
    ggtitle("Densit√© <span style='color:royalblue'>log(qOut)</span> vs. <span style='color:darkred'>loi normale</span>") +
    geom_density(
        color = "royalblue",
        linewidth = 1
    ) +
    stat_function(
        fun = dnorm,
        args = list(
            mean = mean(log(apples$qOut)),
            sd = sd(log(apples$qOut))
        ),
        color = "darkred",
        linewidth = 1
    )
```

> Le test de normalit√© confirme statistiquement le fait que les donn√©es `log(qOut)` suivent une distribution normale (p.value > 0.05)

```{r}
shapiro.test(log(apples$qOut))
```

## Fonction de production lin√©aire

:::{.callout-tip}

## Forme de la fonction

$$
q_i = \alpha + \sum_{k=1}^3\beta_k x_{ik} + Œµ_i
$$

- La **fonction de production lin√©aire** dans notre cas s'√©crit donc sous la forme :

$$
q_{Out} = \alpha + \beta_1 q_{Cap} + \beta_2 q_{Lab} + \beta_3 q_{Mat} + Œµ_i
$$

:::

On a pu constater un lien ind√©niable entre la quantit√© produite (`qOut`) et les productivit√©s moyennes. On peut alors l√©gitimement penser qu'il existe une relation entre la quantit√© produite et les quantit√©s des facteurs de production.

**Avant de s'aventurer dans des formes fonctionnelles plus complexes, commen√ßons par utiliser une simple fonction de production lin√©aire.**

```{r}
#| label: linreg_prod
#| code-fold: false
linreg_prod <- lm(qOut ~ qCap + qLab + qMat, data = apples)
```

```{r}
#| label: linreg_prod_table
#| echo: false
gtgazer(
    linreg_prod,
    n_coef = 4,
    coefnames = c("$\\alpha$", "$\\beta_1$", "$\\beta_2$", "$\\beta_3$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qCap`",
        "- Coefficient associ√© √† la variable `qLab`",
        "- Coefficient associ√© √† la variable `qMat`"
    ),
    title = "**Fonction de production lin√©aire**",
    bg_color = bg_color
)
```

- Le coefficient associ√© √† `qCap` est de 1.788, mais il n'est pas statistiquement significatif, ce qui sugg√®re que la quantit√© de capital n'a pas une influence significative sur la production totale.

- Le coefficient associ√© √† `qLab` est de 11.831 avec un niveau de significativit√© tr√®s √©lev√©, ce qui signifie que pour chaque unit√© suppl√©mentaire de travail utilis√©e, la production totale augmente en moyenne de 11.831 unit√©s. Cela rev√®le une fois de plus l'influence importante de la quantit√© de travail sur la quantit√© d'output.

- Le coefficient associ√© √† `qMat` est de 46.668 avec un niveau de significativit√© tr√®s √©lev√©, ce qui indique que pour chaque unit√© suppl√©mentaire de mat√©riaux utilis√©s, la production totale augmente en moyenne de 46.668 unit√©s.

$R^2_{adj}=$ 0.782 donc 78.2% de la variance de la production totale est expliqu√©e par la variance des variables explicatives.

```{r}
#| label: heterosced_investigate
#| echo: false
predicted_qOut <- predict(linreg_prod) |>
    as_tibble() |>
    rename(predicted_qOut = value)
qOut <- apples |> select(qOut)

residuals <- resid(linreg_prod) |>
    as_tibble() |>
    rename(residuals = value)

bind_cols(qOut, predicted_qOut, residuals) |>
    mutate(diff = predicted_qOut / qOut) |>
    arrange(diff) |>
    gt() |>
    tab_header(title = md("üîé Comparaison de la **production effective** et de la **production pr√©dite**")) |>
    cols_label(
        qOut = md("$q_{Out}$"),
        predicted_qOut = md("$\\widehat{q_{Out}}$"),
        residuals = md("$\\varepsilon_i$"),
        diff = md("$\\widehat{q_{Out}}/q_{Out}$")
    ) |>
    fmt_number(suffixing = TRUE, n_sigfi = 2) |>
    data_color(
        columns = diff,
        rows = diff > 0.7 & diff < 1.3,
        method = "numeric",
        palette = "green",
    ) |>
    cols_align("center") |>
    tab_options(
        table.background.color = bg_color
    ) |>
    opt_interactive(use_highlight = TRUE)
```

### H√©t√©rosc√©dasticit√©

Les r√©sidus sont-ils normalement distribu√©s ?

**TODO : Continuer la partie sur l'h√©t√©rosc√©dasticit√©**

```{r}
#| label: heteroscedasticity

# performance::check_normality(linreg_prod)
# qqnorm(residuals |> pull())
# qqline(residuals |> pull())
# √† changer en ggplot2 ici
```

### Sp√©cification de la forme fonctionnelle

On peut utiliser un **RESET** test pour v√©rifier si la forme fonctionnelle lin√©aire est la bonne sp√©cification.

$$
\begin{cases}
H_0 : \text{La relation entre la variable a predire et un ou plusieurs predicteurs est lineaire} \\
H_1 : \text{La relation entre la variable a predire et un ou plusieurs predicteurs est quadratique}
\end{cases}
$$

```{r}
#| label: reset_linreg
#| echo: false
reset_linreg_prod <- resettest(linreg_prod, power = 2)
```

$\Rightarrow$ la $p-value$ issue du test est $< 0.05$, **on rejette donc l'hypoth√®se nulle $H_0$, c'est √† dire qu'on va pr√©f√©rer prendre une forme fonctionnelle incluant des effets quadratiques.**

```{r}
#| label: ppc_linreg_prod
#| warning: false
#| echo: false
#| fig-align: center
aic_linreg_prod <- AIC(linreg_prod)
loglik_linreg_prod <- logLik(linreg_prod)[1]
check_posterior_predictions(linreg_prod, verbose = FALSE)
```

::: {.callout-caution}

## Inconv√©nients de la forme fonctionnelle lin√©aire

Malgr√© un $R^2_{adj}$ proche de 0.8, ce qui signifie que le mod√®le a plut√¥t un bon ajustement, la sp√©cification lin√©aire poss√®de plusieurs probl√®mes :

1. Elle ne permet pas d'estimer les rendements d'√©chelle car ils sont fix√©s comme constants dans la forme fonctionnelle.
2. Elle ne permet pas d'√©valuer les possibilit√©s de substitution entre les trois facteurs de production.

$\Rightarrow$ Face √† ces inconv√©nients du mod√®le lin√©aire, la fonction **Cobb-Douglas** permet de fournir une r√©ponse au point *(1)*.

:::


## Fonction Cobb-Douglas

:::{.callout-tip}

## Forme de la fonction

$$
q_i = A \prod_{k=1}^3 x_{ik}^{a_k}Œµ_i
$$

- La **fonction de production Cobb-Douglas** dans notre cas s'√©crit donc sous la forme :

$$
q_{Out} = A\cdot q_{Cap}^\alpha \cdot q_{Lab}^\beta \cdot q_{Mat}^\gamma \cdot Œµ_i
$$

On peut aussi facilement lin√©ariser la fonction pour pouvoir la pr√©parer √† une proc√©dure `lm`, d√®s lors on obtient :

$$
\ln(q_{out}) = \ln(A) + \alpha \cdot \ln(q_{Cap}) + \beta \cdot \ln(q_{Lab}) + \gamma \cdot \ln(q_{Mat}) +  \ln{(Œµ_i)}
$$

:::

Le package `micEcon` propose n√©anmoins l'estimation d'une fonction de production **Cobb-Douglas** gr√¢ce √† la fonction `translogEst` et l'argument `linear = TRUE`^[Gr√¢ce √† cet argument, on restreint en fait les coefficients de tous les termes *quadratiques* et d'*interaction* √† z√©ro, ce qui revient √† estimer une fonction **Cobb-Douglas**.].

```{r}
#| label: cd_prod
#| code-fold: false
cd_prod <- translogEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    data = apples,
    linear = TRUE
)
```

```{r}
#| label: cd_prod_table
#| echo: false
gtgazer(
    cd_prod,
    n_coef = 4,
    coefnames = c("$A$", "$\\alpha$", "$\\beta$", "$\\gamma$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qCap`",
        "- Coefficient associ√© √† la variable `qLab`",
        "- Coefficient associ√© √† la variable `qMat`"
    ),
    title = "**Fonction de production Cobb-Douglas**",
    bg_color = bg_color
)
```

```{r}
#| label: cd_prod_metrics
#| echo: false
apples <- apples |> mutate(
    log_qOut = log(qOut),
    log_qCap = log(qCap),
    log_qLab = log(qLab),
    log_qMat = log(qMat)
)

cd_prod_2 <- lm(
    log_qOut ~ log_qCap + log_qLab + log_qMat,
    data = apples
)

aic_cd_prod <- AIC(cd_prod_2)
bic_cd_prod <- BIC(cd_prod_2)
loglik_cd_prod <- logLik(cd_prod_2)[1]
```

- La qualit√© d'ajustement du mod√®le a diminu√©, le $R^2_{adj}$ a baiss√© de pr√®s de 20% pour atteindre 0.585.

```{r}
#| label: cd_prod_posterior
#| fig-align: center
check_posterior_predictions(cd_prod_2)
```

### Rendements d'√©chelle

Les exposants $\alpha$, $\beta$ et $\gamma$ sont les √©lasticit√©s de la production, c'est-√†-dire qu'ils mesurent respectivement le changement en pourcentage de l'output aux variations en pourcentage de la quantit√© de capital, de la quantit√© de travail et de la quantit√© de mat√©riaux.

- Gr√¢ce √† ces coefficients estim√©s, on peut d√©terminer les rendements d'√©chelle.

::: {.callout-note}

## Note sur les rendements d'√©chelle

- **D√©croissants** si $\hat{\alpha} + \hat{\beta} + \hat{\gamma} < 1$

- **Constants** si $\hat{\alpha} + \hat{\beta} + \hat{\gamma} = 1$

- **Croissants** si $\hat{\alpha} + \hat{\beta} + \hat{\gamma} > 1$

:::

```{r}
#| label: return_to_scale
#| code-fold: false
alpha <- cd_prod$coef[2] |> unname()
beta <- cd_prod$coef[3] |> unname()
gamma <- cd_prod$coef[4] |> unname()

return_to_scale <- alpha + beta + gamma
```

- On trouve donc que $\hat{\alpha} + \hat{\beta} + \hat{\gamma} =$ **`r round(return_to_scale, 2)`**, donc les rendements d'√©chelles sont croissants, c'est √† dire que le processus de production est consid√©r√© comme particuli√®rement efficace et pr√©sente des *√©conomies d‚Äô√©chelle*. 

- Ces rendements d‚Äô√©chelle croissants sont souvent le r√©sultat de co√ªts fixes √©lev√©s *(voir la @sec-desc-table pour s'en convaincre)*.

> Une implication de ce r√©sultat est que des installations de production √† grande √©chelle ont tendance √† √™tre plus efficaces que des installations √† petite √©chelle.

***

**Int√©ressons-nous √† l‚Äô√©lasticit√© de substitution, qui mesure la facilit√© avec laquelle un input peut √™tre substitu√© par un autre.**

- Si l'elasticit√© de substitution n'est pas empiriquement estimable pour la **Cobb-Douglas**, celle-ci suppose implicitement que l'√©lasticit√© de substitution de *Allen* est √©gale √† un, soit $\sigma_{\{\text{qCap, qLab, qMat}\}} = 1$. 

- Cela implique une substitution **parfaite** entre les facteurs de production $q_{Cap}$, $q_{Lab}$ et $q_{Mat}$, **ce qui va clairement √† l'encontre des r√©sultats de la @sec-ap-prod**. 

On ne peut donc pas √©tudier les substitutions entre les facteurs de production car la **Cobb-Douglas** ne permet tout simplement pas de le faire ! 

### Productivit√© marginale des inputs

La productivit√© marginale se r√©f√®re √† la variation de la production totale r√©sultant d'une petite variation d'un facteur de production sp√©cifique, *toutes choses √©gales par ailleurs*.

En d'autres termes, il s'agit de la quantit√© suppl√©mentaire d'output qu'une entreprise peut produire en utilisant une unit√© suppl√©mentaire d'un facteur de production donn√©, tout en maintenant constantes les quantit√©s des autres facteurs de production.

Nous obtenons alors respectivement :

- $MP_{Cap} = \frac{\partial q_{Out}}{\partial q_{Cap}}$

- $MP_{Lab} = \frac{\partial q_{Out}}{\partial q_{Lab}}$

- $MP_{Mat} = \frac{\partial q_{Out}}{\partial q_{Mat}}$

On peut facilement calculer ces productivit√©s marginales avec la fonction `cobbDouglasDeriv`.

```{r}
#| label: cd_prod_mp
#| code-fold: false
cd_prod_margProducts <- cobbDouglasDeriv(
    c("qCap", "qLab", "qMat"),
    data = apples, coef = coef(cd_prod)[1:4],
    coefCov = vcov(cd_prod)[1:4, 1:4]
)
```

```{r}
#| label: cd_prod_mp_table
#| echo: false
cd_prod_margProducts$deriv |>
    as_tibble() |>
    rowid_to_column() |>
    gt() |>
    cols_label(
        rowid = md("$N$"),
        qCap = md("$MP_{Cap}$"),
        qLab = md("$MP_{Lab}$"),
        qMat = md("$MP_{Mat}$")
    ) |>
    fmt_number(-rowid) |>
    fmt_integer(rowid, pattern = "Producteur {x}") |>
    cols_align("center") |>
    tab_header(
        title = md("**Productivit√©s marginales**"),
        subtitle = md("*Dans le cadre d'une fonction de production `Cobb-Douglas`*")
    ) |>
    tab_options(
        table.background.color = bg_color
    ) |>
    opt_interactive(use_highlight = TRUE)

# elasticities(cd_prod)
```

- *Par exemple*, pour le producteur 1 : 
  - L'augmentation d'une unit√© de **capital** tout en maintenant constant le niveau de travail et de mat√©riaux entra√Ænera une augmentation de 6.23 unit√©s d'output.
  - L'augmentation d'une unit√© de **travail** tout en maintenant constant le niveau de capital et de mat√©riaux entrainera une augmentation de 6.03 unit√©s d'output.
  - L'augmentation d'une unit√© de **mat√©riaux** tout en maintenant constant le niveau de travail et de capital entrainera une augmentation de 59.09 unit√©s d'output.

> On remarque dans ce mod√®le que la productivit√© marginale des mat√©riaux est sup√©rieure √† celle du capital et du travail **pour tous les producteurs**. De plus, aucune productivit√© marginale n'est n√©gative.

## Fonction de production quadratique

:::{.callout-tip}

## Forme de la fonction

$$
q_i = \alpha + \sum_{k=1}^3\beta_k x_{ik} + \frac{1}{2}\sum_{l=1}^3\sum_{k=1}^3 \beta_{kl}x_{ik}x_{il} + Œµ_i
$$

- La **fonction de production quadratique** dans notre cas s'√©crit donc sous la forme :

$$
\begin{gathered}q_{Out}‚Äã=Œ±+Œ≤_1‚Äãq_{Cap}‚Äã+Œ≤_2‚Äãq_{Lab}‚Äã+Œ≤_3‚Äãq_{Mat}\\
‚Äã+\frac{1}{2}‚Äã(Œ≤_{11}‚Äãq^2_{Cap}‚Äã+Œ≤_{22}‚Äãq^2_{Lab}‚Äã+Œ≤_{33}‚Äãq^2_{Mat})\\
‚Äã+‚ÄãŒ≤_{12}‚Äãq_{Cap}‚Äãq_{Lab}‚Äã+Œ≤_{13}‚Äãq_{Cap}‚Äãq_{Mat}‚Äã+Œ≤_{23}‚Äãq_{Lab}‚Äãq_{Mat}‚Äã+Œµ_i‚Äã
\end{gathered}
$$

:::

**‚úÖ Avantages :** 

- La fonction de production quadratique va permettre d'ajouter des termes *quadratiques* et des effets d'*interaction*, rendant la mod√©lisation plus robuste.

**‚ùå Inconv√©nients :** 

- L'ajout de termes suppl√©mentaires implique plus de complexit√© et de coefficients √† estimer $(3^2 = 9)$.

```{r}
#| label: quad_prod
#| code-fold: false
quad_prod <- quadFuncEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    data = apples
)
```

```{r}
#| label: quad_prod_table
#| echo: false
gtgazer(
    quad_prod,
    n_coef = 9,
    coefnames = c("$\\alpha$", "$\\beta_1$", "$\\beta_2$", "$\\beta_3$", "$\\beta_{11}$", "$\\beta_{12}$", "$\\beta_{13}$", "$\\beta_{22}$", "$\\beta_{23}$", "$\\beta_{33}$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qCap`",
        "- Coefficient associ√© √† la variable `qLab`",
        "- Coefficient associ√© √† la variable `qMat`",
        "- Coefficient associ√© √† la variable `qCap¬≤`",
        "- Coefficient associ√© √† la variable `qCap√óqLab`",
        "- Coefficient associ√© √† la variable `qCap√óqMat`",
        "- Coefficient associ√© √† la variable `qLab¬≤`",
        "- Coefficient associ√© √† la variable `qLab√óqMat`",
        "- Coefficient associ√© √† la variable `qMat¬≤`"
    ),
    title = "**Fonction de production quadratique**",
    bg_color = bg_color
) |> fmt_number(
    columns = coefficients,
    rows = c(5:9),
    decimals = 5,
    drop_trailing_zeros = TRUE
)
```

```{r}
#| label: quad_prod_metrics
#| echo: false
apples <- apples |> mutate(
    qCap2 = 0.5 * qCap^2,
    qLab2 = 0.5 * qLab^2,
    qMat2 = 0.5 * qMat^2
)

quad_prod_2 <- lm(
    qOut ~ qCap + qLab + qMat +
        qCap2 + qLab2 + qMat2 +
        I(qCap * qLab) + I(qLab * qMat) + I(qMat * qCap),
    data = apples
)

aic_quad_prod <- AIC(quad_prod_2)
bic_quad_prod <- BIC(quad_prod_2)
loglik_quad_prod <- logLik(quad_prod_2)[1]
```

- Le coefficient associ√© √† `qCap` est de 5.27, mais il n'est pas statistiquement significatif, ce qui sugg√®re que la quantit√© de capital n'a pas une influence significative sur la production totale dans ce mod√®le.

- Le coefficient associ√© √† `qLab` est de 6.077 avec un niveau de significativit√© assez faible, ce qui signifie que pour chaque unit√© suppl√©mentaire de travail utilis√©e, la production totale augmente en moyenne de 6.077 unit√©s, *toutes choses √©gales par ailleurs*.

- Le coefficient associ√© √† `qMat` est de 14.303, mais il n'est pas statistiquement significatif, ce qui sugg√®re que la quantit√© de mat√©riaux n'a pas une influence significative sur la production totale dans ce mod√®le.

- Le coefficient associ√© √† l'effet d'interaction entre les quantit√©s de capital et de travail (`qCap√óqLab`) est n√©gatif et significatif au seuil de 5%. Cela sugg√®re que l'interaction entre ces 2 facteurs a un effet n√©gatif sur la production.

- Le coefficient associ√© √† l'effet d'interaction entre les quantit√©s de tavail et de mat√©riaux (`qLab√óqMat`) est positif et significatif au seuil de 1%. Cela sugg√®re que l'interaction entre ces 2 facteurs a un effet positif sur la production.

- Enfin, le coefficient associ√© √† l'effet quadratique des mat√©riaux (`qMat¬≤`) est statistiquement significatif au seuil 5% et poss√®de une valeur n√©gative, ce qui sugg√®re une courbe de rendement d'√©chelle d√©croissante pour les mat√©riaux, indiquant que l'augmentation de la quantit√© de mat√©riaux pourrait initialement augmenter la production, mais √† un rythme d√©croissant.

$R^2_{adj} =$ 0.834 donc 83.4% de la variance de la production totale est expliqu√©e par la variance des variables explicatives. Ce r√©sultat est meilleur que les fonctions de production lin√©aire et Cobb-Douglas.



### Productivit√© marginale des inputs

```{r}
#| label: quad_prod_mp
#| code-fold: false
quad_prod_margProducts <- quadFuncDeriv(
    c("qCap", "qLab", "qMat"),
    data = apples,
    coef = coef(quad_prod),
    coefCov = vcov(quad_prod)
)
```

```{r}
#| label: quad_prod_mp_table
#| echo: false
quad_prod_margProducts |>
    as_tibble() |>
    rowid_to_column() |>
    gt() |>
    cols_label(
        rowid = md("$N$"),
        qCap = md("$MP_{Cap}$"),
        qLab = md("$MP_{Lab}$"),
        qMat = md("$MP_{Mat}$")
    ) |>
    fmt_number(-rowid) |>
    fmt_integer(rowid, pattern = "Producteur {x}") |>
    cols_align("center") |>
    tab_header(
        title = md("**Productivit√©s marginales**"),
        subtitle = md("*Dans le cadre d'une fonction de production `quadratique`*")
    ) |>
    tab_options(
        table.background.color = bg_color
    ) |>
    opt_interactive(use_highlight = TRUE)
```

### Elasticit√© de substitution des inputs

**TODO** : √† confirmer ?

```{r}
# elasticities(quad_prod)
```

## Fonction de production Translog
:::{.callout-tip}

## Forme de la fonction

$$
\begin{gathered} \ln(q_i) = \alpha + \sum_{k=1}^3\beta_k\ln(x_{ik})\\ 
+ \frac{1}{2}\sum_{l=1}^3\sum_{k=1}^3 \beta_{kl}\ln(x_{ik})ln(x_{il}) + Œµ_i
\end{gathered}
$$

- La **fonction de production Translog** dans notre cas s'√©crit donc sous la forme :

$$
\begin{gathered}\ln(q_{Out})‚Äã=Œ±+Œ≤_1 \ln(‚Äãq_{Cap})‚Äã+Œ≤_2 \ln(‚Äãq_{Lab})‚Äã+Œ≤_3 \ln(‚Äãq_{Mat})\\
‚Äã+\frac{1}{2}‚Äã(Œ≤_{11}\ln(‚Äãq^2_{Cap})‚Äã+Œ≤_{22}\ln(‚Äãq^2_{Lab})‚Äã+Œ≤_{33}\ln(‚Äãq^2_{Mat}))\\
‚Äã+‚ÄãŒ≤_{12}\ln(‚Äãq_{Cap}‚Äãq_{Lab})‚Äã+Œ≤_{13}‚Äã\ln(q_{Cap}‚Äãq_{Mat})‚Äã+Œ≤_{23}\ln(‚Äãq_{Lab}‚Äãq_{Mat})‚Äã+Œµ_i‚Äã
\end{gathered}
$$

:::

```{r}
#| label: translog_prod
#| code-fold: false
translog_prod <- translogEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    data = apples
)
```

```{r}
#| label: translog_prod_table
#| echo: false
gtgazer(
    translog_prod,
    n_coef = 10,
    coefnames = c("$A$", "$\\beta_1$", "$\\beta_2$", "$\\beta_3$", "$\\beta_{11}$", "$\\beta_{12}$", "$\\beta_{13}$", "$\\beta_{22}$", "$\\beta_{23}$", "$\\beta_{33}$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qCap`",
        "- Coefficient associ√© √† la variable `qLab`",
        "- Coefficient associ√© √† la variable `qMat`",
        "- Coefficient associ√© √† la variable `qCap¬≤`",
        "- Coefficient associ√© √† la variable `qCap√óqLab`",
        "- Coefficient associ√© √† la variable `qCap√óqMat`",
        "- Coefficient associ√© √† la variable `qLab¬≤`",
        "- Coefficient associ√© √† la variable `qLab√óqMat`",
        "- Coefficient associ√© √† la variable `qMat¬≤`"
    ),
    title = "**Fonction de production Translog**",
    bg_color = bg_color
)
```

```{r}
# summary(translog_prod)
elasticities(translog_prod)

# couts marginaux de l'output d‚Äôune fonction de production translog.
margCost <- translogProdFuncMargCost(
    yName = "qOut",
    xNames = c("qCap", "qLab", "qMat"),
    wNames = c("pCap", "pLab", "pMat"),
    data = apples, coef = coef(translog_prod)
)

# si le cout marginal est n√©gatif, alors il est plus avantageux de produire plus du coup.

# si le cout marginal est trop grand, alors le producteur n'a pas forc√©ment interet √† produire plus.

min(margCost)
```

```{r}
mono <- translogCheckMono(
    c("qCap", "qLab", "qMat"),
    data = apples,
    coef = coef(translog_prod),
    increasing = TRUE
)

mono$increasing

mono$obs |>
    as_tibble() |>
    group_by(value) |>
    summarise(n = n())
```

Cette fonction de production **Translog** augmente de mani√®re monotone dans les facteurs de production `qCap`, `qLab`, `qMat`, dans 65,7% des observations

sur les 140 pr√©sentes sur 92 observations 


**Check whether the production function is quasiconcave**

```{r}
translogCheckCurvature(
    c("qCap", "qLab", "qMat"),
    data = apples,
    coef = coef(translog_prod),
    convexity = FALSE,
    quasi = TRUE
)
```

## Machine Learning de production

√Ä titre exp√©rimental, il est envisageable d'explorer l'utilisation du Machine Learning pour √©tudier la production de pommes. Cependant, compte tenu du peu de donn√©es disponibles, cette approche n'est pas id√©ale. Nous envisageons n√©anmoins d'appliquer un algorithme de Random Forest. Ce mod√®le permet d'extraire l'importance des variables, offrant ainsi une certaine transparence dans le fonctionnement de ce mod√®le de Machine Learning souvent per√ßu comme une bo√Æte noire.

Comme pour les fonction de production nous tentons d'expliquer la variable `qOut` √† partir des variables `qLab`, `qCap` et `qMat`.


```{r}
apples_cut <- readxl::read_excel("data/appleProdFr86.xlsx")
apples_cut <- apples_cut[, -c(1:6, 8:12)]
split <- apples_cut |> initial_split(prop = 2 / 3)
df_train <- split |> training()
df_test <- split |> testing()
```

```{r}
# task <- makeRegrTask(data = df_train, target = "qOut")

# Tuning
# estimateTimeTuneRanger(task)
# rf <- tuneRanger(task,
#                 tune.parameters = c("mtry", "min.node.size"),
#                 num.trees = 1000)

# Best model
# params <- rf$recommended.pars
best_model <- ranger(
    formula = qOut ~ .,
    data = df_train,
    mtry = 1, # params$mtry,
    min.node.size = 2, # params$min.node.size,
    importance = "permutation"
)

# Pr√©diction
pred <- predict(best_model, data = df_test)$predictions
```

```{r}
metric_mae <- mean(abs(pred - df_test$qOut))
metric_r2 <- 1 - sum((pred - df_test$qOut)^2) / sum((mean(df_test$qOut) - df_test$qOut)^2)
```

Le coefficient de d√©termination $R^2$ associ√© √† ce mod√®le de Random Forest est de **`r round(metric_r2,3)`**, ce qui est similaire au score que nous avions obtenu pr√©c√©demment.

Avec le graphique ci-dessous, nous pouvons comparer les valeurs pr√©dites et les valeurs r√©elles. La ligne rouge en pointill√©s indique que lorsque les points se trouvent dessus, le mod√®le a fait une pr√©diction parfaite. Cependant, si un point est au-dessus (resp. en-dessous) de la ligne, cela signifie que le mod√®le a sous-estim√© (resp. surestim√©) `qOut`.

```{r}
ggplot() +
    aes(x = pred, y = df_test$qOut) +
    geom_point() +
    geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
    labs(x = "Pr√©diction", y = "R√©alit√©", title = "Comparaison pr√©diction vs. r√©alit√©")
```


Lorsque l'on examine l'importance des variables, on observe que la variable `qLab` exerce le plus grand impact dans le mod√®le Random Forest, tandis que la variable `qCap` a le moins d'influence. C'est tr√®s int√©ressant car la variable `qLab` est syt√©matiquement significative dans les mod√®les pr√©c√©dent.


```{r}
importance <- best_model$variable.importance |>
    as.data.frame()

ggplot(
    data = importance,
    aes(
        x = fct_reorder(
            row.names(importance),
            best_model$variable.importance
        ),
        y = best_model$variable.importance
    )
) +
    geom_bar(stat = "identity", fill = "royalblue", alpha = 0.5, width = 0.5) +
    labs(x = "Variables", y = "Importance", title = "Importance des variables") +
    coord_flip()
```

En r√©sum√©, dans notre contexte, le Machine Learning ne semble pas apporter une valeur ajout√©e significative. Le mod√®le obtenu n'est pas plus performant que les mod√®les pr√©c√©dents, et nous perdons l'avantage de disposer de coefficients associ√©s √† chaque variable.


## Fonction de production CES

:::{.callout-tip}

## Forme de la fonction

$$
\begin{gathered} q_i = \alpha + \sum_{k=1}^3\beta_k\ln(x_{ik})\\ 
+ \frac{1}{2}\sum_{l=1}^3\sum_{k=1}^3 \beta_{kl}\ln(x_{ik})ln(x_{il}) + Œµ_i
\end{gathered}
$$

- La **fonction de production CES** dans notre cas s'√©crit donc sous la forme :

$$
q_{Out} = A[\delta_1 q_{Cap}^{-\rho} + \delta_2 q_{Lab}^{-\rho} + \delta_3 q_{Mat}^{-\rho}]^{-\frac{1}{\rho}}
$$

:::


## Fonction de production SFA 

Dans le mod√®le **SFA** *(Stochastic Frontier Analysis)*, on introduit un terme multiplicatif $TE_i$. Ce terme repr√©sente l‚Äôefficacit√© technique, d√©finie comme le ratio d‚Äôoutput observ√© sur l‚Äôoutput
maximum r√©alisable, soit : $TE_i = \frac{y_i}{y_i^*}$. 

- On peut r√©-√©crire ce $TE_i$ sous la forme $\exp\left\{-u_i\right\}$.

> **Utiliser un tel mod√®le va donc nous permettre de pouvoir estimer l'efficacit√© technique producteur par producteur.**

*Note* : Nous pouvons utiliser plusieurs formes fonctionnelles pour ce mod√®le, sous la contrainte que notre variable √† pr√©dire soit mise sous forme logarithmique, ce qui √©limine *de facto* les mod√®les de production lin√©aire et quadratique.

::: {.callout-tip}

## Forme de la fonction

$$
q_i = A\prod_{k=1}^3x_{ik}^{a_k}\cdot 
\underbrace{\exp\left\{-u_i\right\} \cdot \exp\left\{v_i\right\}}_{\varepsilon_i}
$$

- La fonction de production **SFA Cobb-Douglas** dans notre cas s‚Äô√©crit donc sous la forme :

$$
q_{Out} = A\cdot q_{Cap}^\alpha \cdot q_{Lab}^\beta \cdot q_{Mat}^\gamma \cdot \exp\left\{-u_i\right\} \cdot \exp\left\{v_i\right\}
$$

En lin√©arisant on obtient : 

$$
\ln(q_{out}) = \ln(A) + \alpha \cdot \ln(q_{Cap}) + \beta \cdot \ln(q_{Lab}) + \gamma \cdot \ln(q_{Mat}) + v_i - u_i
$$

:::

```{r}
cd_sfa <- sfa(log(qOut) ~ log(qCap) + log(qLab) + log(qMat), data = apples)

cd_sfa$olsParam # on retrouve les m√™mes params que la cobb douglas ici
summary(cd_sfa)
```

```{r}
lrtest(cd_sfa) # interpr√©tation : la SFA c'est wallah mieux que la Cobb Douglas classique.

# Note => Faire plus de tests de comparaison de mod√®les : translog vs cobb douglas, etc...

resettestFrontier(cd_sfa, power = 2)
# notre mod√®le

effic <- efficiencies(cd_sfa)

effic |>
    as_tibble() |>
    summarise(
        mean_eff = mean(efficiency),
        min_eff = min(efficiency),
        max_eff = max(efficiency)
    )

```

$LR = 2\cdot(\ln \mathcal{L}_1-\ln \mathcal{L}_2)$

le `resettest` permet $\Rightarrow$ de tester si des combinaisons non-lin√©aires des variables explicatives aident √† expliquer the response variable. 

The intuition behind the test is that if non-linear combinations of the explanatory variables have any power in explaining the response variable, the model is misspecified in the sense that the data generating process might be better approximated by a polynomial or another non-linear functional form. 


## Fonction de co√ªt Cobb Douglass
:::{.callout-tip}

## Forme de la fonction
$$
c_i = A \prod_{k=1}^{3} p_{ik}^{\alpha_k}q_i^{\alpha_y} \epsilon_i
$$

:::

> Calculons d'abord le co√ªt total des inputs, c'est √† dire $v_{Cap} + v_{Lab} + v_{Mat}$.

```{r}
#| label: total_cost
#| code-fold: false
apples <- apples |> mutate(cost = vCap + vLab + vMat)
```

```{r}
cobb_cost <- translogCostEst(
    cName = "cost",
    yName = "qOut",
    pName = c("pCap", "pLab", "pMat"),
    apples, homPrice = FALSE,
    linear = TRUE
)
```

```{r}
summary(cobb_cost$est)
```

```{r}
gtgazer(
    cobb_cost,
    n_coef = 4,
    coefnames = c("$A$", "$\\alpha_1$", "$\\alpha_2$", "$\\alpha_3$", "$\\alpha_4$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qOut`",
        "- Coefficient associ√© √† la variable `pCap`",
        "- Coefficient associ√© √† la variable `pLab`",
        "- Coefficient associ√© √† la variable `pMat`"
    ),
    title = "**Fonction de co√ªt Cobb Douglass**",
    bg_color = bg_color
)
```

## Fonction de co√ªt Cobb Douglass de court terme

:::{.callout-tip}

## Forme de la fonction
$$
c_i = A x_{i3}^{\alpha_3}\prod_{k=1}^{2} p_{ik}^{\alpha_k}q_i^{\alpha_y} \epsilon_i
$$

:::

```{r}
cobb_cost_ct <- translogCostEst(
    cName = "cost",
    yName = "qOut",
    pName = c("pLab", "pMat"),
    fNames = "pCap",
    apples, homPrice = FALSE,
    linear = TRUE
)
```

```{r}
summary(cobb_cost_ct$est)
```

```{r}
gtgazer(
    cobb_cost_ct,
    n_coef = 4,
    coefnames = c("$A$", "$\\alpha_1$", "$\\alpha_2$", "$\\alpha_3$", "$\\alpha_4$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qOut`",
        "- Coefficient associ√© √† la variable `pCap`",
        "- Coefficient associ√© √† la variable `pLab`",
        "- Coefficient associ√© √† la variable `pMat`"
    ),
    title = "**Fonction de co√ªt Cobb Douglass de court terme**",
    bg_color = bg_color
)
```

## Fonction de co√ªt Translog

:::{.callout-tip}

## Forme de la fonction

$$
\begin{gathered}ln(c_i) = \alpha + \sum_{k=1}^3 \beta_k ln(p_{ik}) + \alpha_qln(q_i) \\ +\frac{1}{2}\sum_{l=1}^3\sum_{k=1}^3\beta_{kl}ln(p_{ik})ln(p_{il})\frac{1}{2}\alpha_{q}(ln(q_i))^2 \\
+\frac{1}{2}\sum_{k=1}^3\alpha_{kq}ln(p_{ik})ln(q_i)+\epsilon_i
\end{gathered}
$$

:::

```{r}
translog_cost <- translogCostEst(
    cName = "cost",
    yName = "qOut",
    pName = c("pCap", "pLab", "pMat"),
    apples, homPrice = FALSE
)
```

```{r}
summary(translog_cost$est)
```

```{r}
gtgazer(
    translog_cost,
    n_coef = 9,
    coefnames = c("$A$"),
    description = c(
        "- Constante du mod√®le"
    ),
    title = "**Fonction de co√ªt Translog**",
    bg_color = bg_color
)
```

## Profit des producteurs

```{r}
apples |>
    select(pOut, qOut, cost) |>
    mutate(profit = (pOut * qOut) - cost)
```

## Infos sur le sujet | ROADMAP

$\Rightarrow$ Estimer des fonctions de cout, les rendements d'√©chelle, estimer la fonction CES, la leontieff g√©n√©ralis√©e, calculer le profit des producteurs, lien entre efficacit√©, optimalit√©, v√©rifier h√©t√©rosc√©dasticit√©, mod√®les SFA et DEA potentiellement.

La translog ayant bcp plus de param√®tres, ce ne sera pas forc√©ment la bonne forme fonctionnelle !

- [ ] Expliquer les diff√©rences de profits entre les producteurs ? Regarder du cot√© des fonctions de profit.

Propri√©t√© de la CD => si la fonction de prod est cobb douglas, alors la fonction de co√ªt l'est aussi.

- [ ] Pour la question 7, on int√®gre la quantit√© d'inputs comme variable explicative => fonction de cout de court terme

- [ ] Fonction de cout qui int√®gre que la quantit√© de capital ne change pas instantan√©ment


- [ ] Rendements d'√©chelle (somme des exposants) => on peut trouver ces rendements d'√©chelle soit en faisant la fonction de co√ªt, ou la fonction de production. Mais on peut aussi les estimer grace √† une fonction de demande

**DEUX CHOSES ESSENTIELLES**


- Il faut estimer les substitutions entre facteurs
- Les rendements d'√©chelle

Regarder le $\prod$


### Notes sur la translog Cost

On pourrait tt √† fait estimer le syst√®me d'√©quations suivant :

Voir aussi la slide 78 sur la fonction $\ln C$

$$
\begin{cases}
S_1 = \alpha_1 + \sum^3_{i=1} \beta_{1j}\ln p_j + \beta_{1y}\ln y\\
S_2 = \alpha_2 + \sum^3_{i=1} \beta_{2j}\ln p_j + \beta_{2y}\ln y\\
S_3 = \alpha_3 + \sum^3_{i=1} \beta_{3j}\ln p_j + \beta_{3y}\ln y
\end{cases}
$$

Inconv√©nients dans la translog et des formes flexibles : 

Le nombre de param√®tres explose √† cause des effets crois√©s et risque important de collin√©arit√©.

Quand on passe au syst√®me au tableau, on a augment√© √† 3*140 donn√©es (420 observations) et on a un peu moins de param√®tres

- Les entreprises les plus grosses sont les plus productives.


[done üíÖ]{style="color:red;"}