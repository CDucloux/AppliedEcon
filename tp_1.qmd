---
title: "{{< fa flask >}} **Econom√©trie Appliqu√©e**"
title-block-banner: apples.png
subtitle: "Des üçè sur {{< fa brands r-project >}} !"
toc: true
toc-title: üìö Table des mati√®res
lang: fr
number-sections: true
author:
  - name: "*Corentin Ducloux*"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
  - name: "*Guillaume Devant*"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
date: today
date-format: short
include-in-header: 
    - text: | 
        <link href='https://fonts.googleapis.com/css?family=Fira Code' rel='stylesheet'>
format:
    html:
        theme: simplex
        monofont: "Fira Code"
        fontsize: 1em
        embed-resources: true
        html-math-method: mathjax
        code-fold: true 
        anchor-sections: true
        smooth-scroll: true
        citations-hover: true
        footnotes-hover: true
        link-external-icon: true
        link-external-newwindow: true
code-block-bg: "#F1F3F5"
code-block-border-left: "#d9230f"
license: "CC BY-SA"
bibliography: references.bib
crossref:
    eq-prefix: √©quation
    tbl-prefix: Tableau
editor_options: 
    chunk_output_type: console
---

```{css, echo=FALSE}
.title {
    color: white;
}
.subtitle {
    color: white;
}
```

```{r}
#| label: functions

makestars <- function(pvalues) {
    return(
        dplyr::case_when(
            pvalues < 0.001 ~ "$***$",
            pvalues < 0.05 ~ "$**$",
            pvalues < 0.1 ~ "$*$",
            .default = ""
        )
    )
}


gtgazer <- function(model, n_coef = 4, coefnames, description, title, bg_color) {
    coefficients <- summary(model)$coefTable[1:n_coef, 1]
    std_values <- summary(model)$coefTable[1:n_coef, 2]
    pvalues <- summary(model)$coefTable[1:n_coef, 4]
    signif <- makestars(pvalues)
    r2 <- round(summary(model)$r2, 3)
    adj_r2 <- round(summary(model)$r2bar, 3)
    n <- summary(model)$nObs
    dep_variable <- summary(model)$yName
    coefnames <- coefnames
    description <- description
    reg_results <- data.frame(cbind(coefnames, description, coefficients, std_values, pvalues, signif)) |>
        tibble() |>
        mutate(across(c(coefficients, std_values, pvalues), as.numeric))

    table <- reg_results |>
        gt(rowname_col = "coefnames") |>
        cols_label(
            description = md("**Description**"),
            coefficients = md("**Coefficients**"),
            std_values = md("**Ecart Type**"),
            pvalues = md("**Pvalues**"),
            signif = md("**Significativit√©**")
        ) |>
        fmt_markdown(columns = c(coefnames, signif, description)) |>
        fmt_number(columns = c(coefficients, pvalues), decimals = 3) |>
        fmt(columns = std_values, fns = function(std) {
            paste("+/-", round(std, 3))
        }) |>
        tab_footnote(footnote = md(sprintf("*Observations* : %s", n))) |>
        tab_footnote(footnote = md("***")) |>
        tab_footnote(footnote = md(sprintf("$R^2=$ %s", r2))) |>
        tab_footnote(footnote = md(sprintf("$R^2_{adj}=$ %s", adj_r2))) |>
        tab_header(
            title = md(title),
            subtitle = md(sprintf("Variable d√©pendante : *%s*", dep_variable))
        ) |>
        tab_options(
            table.background.color = bg_color
        )

    return(table)
}
```

## Imports et configuration

:::{.callout-note}

Tout au long de ce projet, nous utiliserons l'approche [`tidy`](https://www.tidyverse.org/) d√©velopp√©e par @wickham2014 plut√¥t que l'approche `base R` pour manipuler nos donn√©es.

:::


```{r}
#| label: lib_imports
#| warning: false
library(ggplot2)
library(dplyr)
library(readxl)
library(micEcon)
library(stargazer)
library(gt)
library(tibble)
library(knitr)
library(plotly)
library(patchwork)
library(showtext)
library(FactoMineR)
library(factoextra)
library(ggtext)
```

```{r}
#| label : colors
bg_color <- "#FCFCFC"
alpha <- 0.7
```

```{r}
theme_set(theme_minimal())
thematic::thematic_on(bg = "#FCFCFC", fg = "black", accent = "purple", font = "PT Sans")
```

## Description des donn√©es

Le jeu de donn√©es `appleProdFr86` utilis√© dans le papier d'√©conom√©trie de @ivaldi1996 comprend des donn√©es transversales de production de **140** producteurs de pommes fran√ßais datant de l‚Äôann√©e 1986. 

```{r}
#| label: data_import
apples <- read_excel("data/appleProdFr86.xlsx")
```

| Colonnes    | Description                                                                                              |
|-------------|----------------------------------------------------------------------------------------------------------|
| `vCap`      | Co√ªts associ√©s au **capital** *(foncier compris)*.                                                       |
| `vLab`      | Co√ªts associ√©s au **travail** *(y compris la r√©mun√©ration du travail familial non r√©mun√©r√©)*.            |
| `vMat`      | Co√ªts des **mati√®res interm√©diaires** *(plantations, engrais, pesticides, carburant, etc)*.              |
| `qApples`   | Indice de quantit√© des pommes produites.                                                                 |
| `qOtherOut` | Indice de quantit√© de tous les autres outputs.                                                           |
| `qOut`      | Indice de quantit√© de toute la production $\Rightarrow 580000 \cdot (\text{qApples} + \text{qOtherOut})$ |
| `pCap`      | Indice des prix du **capital**.                                                                           |
| `pLab`      | Indice des prix du **travail**.                                                                           |
| `pMat`      | Indice des prix des **mati√®res interm√©diaires**.                                                          |
| `pOut`      | Indice des prix de la production globale.                                                                 |
| `adv`       | Distingue les producteurs qui sont conseill√©s par des laboratoires d'agronomie.                           |

: Descriptif des colonnes {.hover}

### Tableau descriptif

> Ce tableau descriptif retrace les 10 premi√®res observations et l'ensemble des variables associ√©es dans le *dataset*.

```{r}
#| label: descriptive table
apples |>
    head(n = 10) |>
    gt() |>
    tab_header(
        title = md("**Producteurs de pommes üçé**"),
        subtitle = md("*140 producteurs* üá´üá∑ *(1986)*")
    ) |>
    tab_source_note(
        source_note = "Source: Ivaldi et al. (1996)"
    ) |>
    tab_spanner(
        label = "Costs",
        columns = c("vCap", "vLab", "vMat")
    ) |>
    tab_spanner(
        label = "Price Index",
        columns = c("pCap", "pLab", "pMat", "pOut")
    ) |>
    tab_spanner(
        label = "Quantity Index",
        columns = c("qApples", "qOtherOut", "qOut")
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "lavenderblush")
        ),
        location = cells_body(columns = c(vCap, vLab, vMat))
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "ivory")
        ),
        location = cells_body(columns = c(qApples, qOtherOut, qOut))
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "aliceblue")
        ),
        location = cells_body(columns = c(pCap, pLab, pMat, pOut))
    ) |>
    fmt_number(suffixing = TRUE, n_sigfi = 2) |>
    text_case_match(
        "1.0" ~ fontawesome::fa("check"),
        "0" ~ fontawesome::fa("xmark"),
        .locations = cells_body(columns = adv)
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

## Statistiques descriptives

### Productivit√© moyenne des facteurs de production 

La productivit√© moyenne ($AP =$ **Average Product**) consiste √† diviser la quantit√© totale d'output par la quantit√© totale de facteur utilis√© *(input)* dans le processus de production.

Imaginons que les unit√©s d'output sont des tonnes. Pour chaque input, cela revient en fait √† expliquer combien de tonnes sont produites par unit√© de capital, de travail et de mati√®res interm√©diaires en 1986 pour chaque producteur de pommes.

Nous obtenons alors respectivement :

- $AP_{Cap} = \frac{q_{Out}}{q_{Cap}}$

- $AP_{Lab} = \frac{q_{Out}}{q_{Lab}}$

- $AP_{Mat} = \frac{q_{Out}}{q_{Mat}}$


```{r}
#| label: productivites
apples <- apples |> mutate(
    AP_Cap = qOut / qCap,
    AP_Lab = qOut / qLab,
    AP_Mat = qOut / qMat
)
```

```{r}

tibble_AP_Cap <- apples |>
    summarise(min = min(AP_Cap), mean = mean(AP_Cap), max = max(AP_Cap), std = sd(AP_Cap)) |>
    add_column(type = "$AP_{Cap}$", .before = "min")
tibble_AP_Lab <- apples |>
    summarise(min = min(AP_Lab), mean = mean(AP_Lab), max = max(AP_Lab), std = sd(AP_Lab)) |>
    add_column(type = "$AP_{Lab}$", .before = "min")
tibble_AP_Mat <- apples |>
    summarise(min = min(AP_Mat), mean = mean(AP_Mat), max = max(AP_Mat), std = sd(AP_Mat)) |>
    add_column(type = "$AP_{Mat}$", .before = "min")

AP_table <- bind_rows(tibble_AP_Cap, tibble_AP_Lab, tibble_AP_Mat)

AP_table |>
    gt() |>
    fmt_markdown(columns = type) |>
    fmt_number(columns = c(-type)) |>
    tab_header(
        title = md("**Productivit√© Moyenne par Facteur üìã**"),
        subtitle = md("*Capital --- Travail --- Mat√©riaux*")
    )
```

Ce tableau, en plus des visualisations qui vont suivre, permet d'√©tablir que les productivit√©s moyennes par facteur sont **tr√®s diff√©rentes selon les producteurs**. De plus, on s'aper√ßoit aussi qu'investir dans un facteur particulier peut √™tre plus int√©ressant qu'un autre. 

C'est particuli√®rement vrai pour le facteur `Mat` avec une productivit√© moyenne minimale de **8.22** unit√©s d'output pour une unit√© de mat√©riaux et jusqu'√† **301.43** unit√©s d'output pour une unit√© de mat√©riaux.

```{r}
apples |>
    ggplot() +
    aes(x = AP_Cap) +
    geom_histogram(binwidth = 1.25, fill = "darkgreen", alpha = alpha) +
    labs(title = "Productivit√© Moyenne du Capital", subtitle = "Pour une unit√© de capital, combien d'unit√©s d'output sont produits ?", x = "", y = "Fr√©quence")
```

```{r}
apples |>
    ggplot() +
    aes(x = AP_Lab) +
    geom_histogram(binwidth = 0.75, fill = "orange", alpha = alpha) +
    labs(title = "Productivit√© Moyenne du Travail", subtitle = "Pour une unit√© de travail, combien d'unit√©s d'output sont produits ?", x = "", y = "Fr√©quence")
```

```{r}
apples |>
    ggplot() +
    aes(x = AP_Mat) +
    geom_histogram(binwidth = 1.5, fill = "darkorchid", alpha = alpha) +
    labs(title = "Productivit√© Moyenne des mat√©riaux", subtitle = "Pour une unit√© de mat√©riaux, combien d'unit√©s d'output sont produits ?", x = "", y = "Fr√©quence")
```

### Corr√©lations entre les quantit√©s des 3 facteurs de production

```{r}
apples |>
    select(qCap, qLab, qMat) |>
    cor() |>
    round(2) |>
    data.frame() |>
    gt() |>
    tab_header("Matrice de corr√©lation")
```

### Corr√©lations entre les productivit√©s moyennes

```{r}
apples |>
    select(starts_with("AP")) |>
    cor() |>
    round(2) |>
    data.frame() |>
    gt() |>
    tab_header("Matrice de corr√©lation")
```

$\Rightarrow$ Id√©e : Faire des r√©gressions lin√©aires sur ces graphs. √©tudier la relation. Normalement on devrait retrouver les coefs de la matrice de corr√©lation. On voit aussi que pour le 2e graph il y a une belle relation lin√©aire.

```{r}
CL <- apples |>
    ggplot() +
    aes(x = AP_Cap, y = AP_Lab) +
    geom_point(colour = "slategray", alpha = alpha)
ML <- apples |>
    ggplot() +
    aes(x = AP_Mat, y = AP_Lab) +
    geom_point(colour = "gray", alpha = alpha)
CM <- apples |>
    ggplot() +
    aes(x = AP_Cap, y = AP_Mat) +
    geom_point(colour = "gray21", alpha = alpha)

prod_plots <- (CL + ML) / CM

prod_plots + plot_annotation(
    title = "Croisement des productivit√©s moyennes",
    subtitle = "Quelles sont les relations existantes entre les diff√©rentes productivit√©s moyennes ?",
    caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
)
```


```{r}
QC <- apples |>
    ggplot() +
    aes(y = qOut, x = AP_Cap) +
    geom_point(colour = "darkgreen", alpha = alpha) +
    labs(y = "") +
    theme(axis.text.y = element_blank(), axis.ticks = element_blank())
QL <- apples |>
    ggplot() +
    aes(y = qOut, x = AP_Lab) +
    geom_point(colour = "orange", alpha = alpha) +
    labs(y = "") +
    theme(axis.text.y = element_blank(), axis.ticks = element_blank())
QM <- apples |>
    ggplot() +
    aes(y = qOut, x = AP_Mat) +
    geom_point(colour = "darkorchid", alpha = alpha) +
    labs(y = "") +
    theme(axis.text.y = element_blank(), axis.ticks = element_blank())

qOut_prod_plots <- (QC + QL) / QM

qOut_prod_plots + plot_annotation(
    title = "Productivit√© moyenne par rapport √† l'output total",
    subtitle = "Quelles sont les relations existantes entre les productivit√©s moyennes des inputs et de l'output ?",
    caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
)
```


On a pu constater un lien ind√©niable entre la quantit√© produite (`qOut`) et les productivit√©s moyennes. On peut alors l√©gitimement penser qu'il y a une relation entre la quantit√© produite et les quantit√©s des facteurs de production. On peut effectuer une r√©gression lin√©aire pour observer cette relation.

La relation lin√©aire est significative entre `qOut` et les variables explicatives `qMat` et `qLab.` Le $R^2$, sup√©rieur √† 0.78, d√©montre la bonne qualit√© de la r√©gression. De ce mod√®le on peut dire que la quantit√© produite d√©pend principalement de la quanit√© de travail et de mati√®re premi√®re engag√©.

```{r}
reg_qOut_AP <- lm(qOut ~ qMat + qLab + qCap ,data = apples)
stargazer(reg_qOut_AP, type = 'text')
```

### Paasche ou Laspeyeres ou Fisher



### Indice de productivit√© globale des facteurs

$$
GP = \frac{q_{Out}}{q_{Cap} + q_{Lab} + q_{Mat}}
$$

```{r}
apples <- apples |> mutate(global_prod = qOut / (qCap + qLab + qMat))

apples |> select(global_prod)
```

```{r}
apples |>
    ggplot() +
    aes(x = global_prod) +
    geom_histogram(binwidth = 0.25, fill = "darkred", alpha = 0.7) +
    labs(title = "Productivit√© globale", x = "Productivit√©", y = "Fr√©quence")
```

```{r}
apples |>
    ggplot() +
    aes(x = global_prod, fill = as.factor(adv)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Productivit√© globale en fonction conseil ou non") +
    theme(legend.position = "None")
```


## Analyse exploratoire

L'ACP permet de constater qu'il y a une opposition entre le prix du capital et la quantit√© de capital, ce qui est √©conomiquement trivial. De plus on observe un fort lien entre le prix du capital et le prix des outputs.

```{r}
apples_acp <- apples[-c(96,129),-c(1, 16:19)]
acp <- PCA(apples_acp, graph = FALSE)

fviz_pca_biplot(acp,
                repel = TRUE,
                title = "ACP - Biplot",
                label = "var",
                col.var = "royalblue",
                col.ind = "orange",
                axes = c(1,2))
```

```{r}
apples |> 
  ggplot() +
  geom_histogram(aes(x = log(qOut)),
                 alpha = 0.6,
                 bins = 25,
                 fill = "royalblue",
                 color = "royalblue") +
  labs(title = "R√©partition de log(qOut)",
       x = "Values",
       y = "Frequency")
```

```{r}
library(ggtext)
apples |> 
  ggplot()+
  geom_density(aes(x = log(qOut)),
               color = "royalblue",
               linewidth = 1)+
  stat_function(fun = dnorm,
                args = list(
                  mean = mean(log(apples$qOut)),
                  sd = sd(log(apples$qOut))
                ),
                color = "darkred",
                linewidth = 1)+
  labs(x = "log()",
       y = "Fr√©quence") + 
  theme(plot.title = element_markdown(face = "bold", size = 15)) +
  ggtitle("Densit√© <span style='color:royalblue'>log(qOut)</span> vs. <span style='color:darkred'>loi normale</span>")
```

> Le test de normalit√© rejette le fait que les donn√©es `qOut` suivent une distribution normale

```{r}
shapiro.test(apples$qOut)
```




### Infos sur le sujet
$$
Q = f(QCAP, QLAB, QMAT)\\
$$

il y a aussi les infos sur $C(Q)$

Comparer les productivit√©s des facteurs. (graphiquement) - imaginons que les unit√©s sont des tonnes (combien de tonnes sont produites par unit√© de travail, capital, etc.)

Comment ces productivit√©s individuelles sont corr√©l√©es (entre QCAP, QLAB, QMAT) 

- Indice de Paasche
- Indice de Laspeyres
- Indice de Fisher

Expliquer les diff√©rences de profits entre les producteurs ? Regarder du cot√© des fonctions de profit.

Propri√©t√© de la CD => si la fonction de prod est cobb douglas, alors la fonction de co√ªt l'est aussi.

alpha y => mesure des rendements d'√©chelle...

Pour la question 7, o nint√®gre la quantit√© d'inputs comme variable explicative => fonction de cout de court terme

Fonction de cout qui int√®gre que la quantit√© de capital ne change pas instantan√©ment


Rendements d'√©chelle (somme des exposants) => on peut trouver ces rendements d'√©chelle soit en faisant la fonction de co√ªt, ou la fonction de production. Mais on peut aussi les estimer grace √† une fonction de demande

**DEUX CHOSES ESSENTIELLES**


- Il faut estimer les substitutions entre facteurs
- Les rendements d'√©chelle


Dans la cobb douglas les substitutions entre facteurs il est constant et c'est 1.

Regarder le $\prod$


### Notes sur la translog Cost

On pourrait tt √† fait estimer le syst√®me d'√©quations suivant :

Voir aussi la slide 78 sur la fonction $\ln C$

$$
\begin{cases}
S_1 = \alpha_1 + \sum^3_{i=1} \beta_{1j}\ln p_j + \beta_{1y}\ln y\\
S_2 = \alpha_2 + \sum^3_{i=1} \beta_{2j}\ln p_j + \beta_{2y}\ln y\\
S_3 = \alpha_3 + \sum^3_{i=1} \beta_{3j}\ln p_j + \beta_{3y}\ln y
\end{cases}
$$

Inconv√©nients dans la translog et des formes flexibles : 

Le nombre de param√®tres explose √† cause des effets crois√©s et risque important de collin√©arit√©.

Quand on passe au syst√®me au tableau, on a augment√© √† 3*140 donn√©es (420 observations) et on a un peu moins de param√®tres

```{r}
apples |>
    select(qApples, adv) |>
    group_by(adv) |>
    summarise(mean = mean(qApples))
```

## Fonction Cobb-Douglas

:::{.callout-tip}

## Forme g√©n√©rale d'une fonction Cobb-Douglas

La forme est g√©n√©ralis√©e √† $N$ inputs.

$$y = A \prod_{k=1}^N x_k^{a_k}$$

:::

Dans le cadre de cette √©tude comparative, nous avons 3 *inputs* :

- `qCap` $\Rightarrow$ la quantit√© de capital
- `qLab` $\Rightarrow$ la quantit√© de travail
- `qMat` $\Rightarrow$ la quantit√© de mat√©riaux

Nous obtenons donc la forme suivante :

$$q_{Out} = A\cdot q_{Cap}^\alpha \cdot q_{Lab}^\beta \cdot q_{Mat}^\gamma$$

*Avec $A, \alpha, \beta, \gamma \Rightarrow$ 4 param√®tres √† estimer.*

On peut facilement lin√©ariser la fonction, d√®s lors on obtient :

$$
\ln(q_{out}) = \ln(A) + \alpha \cdot \ln(q_{Cap}) + \beta \cdot \ln(q_{Lab}) + \gamma \cdot \ln(q_{Mat})
$$

Allen Elasticity of Substitution (AES)

$\sigma_{\{\text{qCap, qLab, qMat}\}} = 1$


**Rappel** : Si la fonction de production est **Cobb-Douglas**, alors on a normalement $\hat\alpha + \hat\beta + \hat\gamma = 1$

On peut tester cette hypoth√®se : 

$$
\begin{cases}
H_0 : \alpha + \beta + \gamma = 1\\
H_1 : \alpha + \beta + \gamma \neq 1\\
\end{cases}
$$


```{r}
# Estime une fonction de production Cobb Douglas avec l'argument linear
cd_prod <- translogEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    apples,
    linear = TRUE
)

quad_prod <- quadFuncEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    apples
)

summary(quad_prod$est)

# elasticities(cd_prod)
# elasticities(quad_prod)
```

```{r}
gtgazer(
    cd_prod,
    n_coef = 4,
    coefnames = c("$A$", "$\\alpha$", "$\\beta$", "$\\gamma$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qCap`",
        "- Coefficient associ√© √† la variable `qLab`",
        "- Coefficient associ√© √† la variable `qMat`"
    ),
    title = "**Fonction de production Cobb-Douglas**",
    bg_color = bg_color
)
```


```{r}
summary(cd_prod$est)
```


```{r}
apples <- apples |> mutate(cost = vCap + vLab + vMat)
```

```{r}
# Estime une fonction Cobb Douglas avec l'argument linear
# translogCostEst("cost", "qOut", c("qCap", "qLab", "qMat"), apples)
```

- Avec la fonction de cout on trouve 2.7 -- √† v√©rifier 

Estimer des fonctions de cout, les rendements d'√©chelle, estimer la fonction CES, la leontieff g√©n√©ralis√©e, calculer le profit des producteurs, lien entre efficacit√©, optimalit√©, v√©rifier h√©t√©rosc√©dasticit√©.

```{r}
cobbDouglasCalc(c("qCap", "qLab", "qMat"), apples, coef(cd_prod)[1:4], coefCov = NULL, dataLogged = FALSE)
```


[done üíÖ]{style="color:red;"}