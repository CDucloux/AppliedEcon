---
title: "{{< fa flask >}} **Econom√©trie Appliqu√©e**"
title-block-banner: imgs/apples.png
subtitle: "Des üçè sur {{< fa brands r-project >}} !"
toc: true
toc-title: üìö Table des mati√®res
lang: fr
number-sections: true
author:
  - name: "{{< fa brands github >}} [*Corentin Ducloux*](https://github.com/CDucloux)"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
  - name: "{{< fa brands github >}} [*Guillaume Devant*](https://github.com/devgui37)"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
date: today
date-format: short
include-in-header: 
    - text: | 
        <link href='https://fonts.googleapis.com/css?family=Fira Code' rel='stylesheet'>
format:
    html:
        theme: simplex
        monofont: "Fira Code"
        fontsize: 1em
        embed-resources: true
        html-math-method: mathjax
        code-fold: true 
        anchor-sections: true
        smooth-scroll: true
        citations-hover: true
        footnotes-hover: true
        link-external-icon: true
        link-external-newwindow: true
code-block-bg: "#F1F3F5"
code-block-border-left: "#d9230f"
license: "CC BY-SA"
bibliography: references.bib
crossref:
    eq-prefix: √©quation
    tbl-prefix: Tableau
editor_options: 
    chunk_output_type: console
---

```{css, echo=FALSE}
.img-block {
    margin: auto;
    width: 85%;
    padding: 10px;
    text-align: center;
}
.img-block img {
    display: inline-block;
    margin: auto;
    max-width: 100%;
}
.title {
    color: white;
}
.subtitle {
    color: white;
}
```

***

:::{.img-block}
<br>
<img src="imgs/MECEN_logo.png" alt="MECEN Logo" style="width: 30%;">
<img src="imgs/UT_logo.jpg" alt="UT Logo" style="width: 45%;">

:::

***

```{r}
#| label: functions
#| echo: false

source("R/custom_functions.R")
```

**TODOS**

- [ ] Rendements d'√©chelle pour la quadratique avec $\lambda$ tr√®s tr√®s bancal

## Imports et configuration

:::{.callout-note}

Tout au long de ce projet, nous utiliserons l'approche [`tidy`](https://www.tidyverse.org/) d√©velopp√©e par @wickham2014 plut√¥t que l'approche `base R` pour manipuler nos donn√©es. De plus, l'utilisation du package `micEcon` et de ses annexes nous facilitera grandement le travail d'estimation -- voir @henningsen2017.

:::

```{r}
#| label: lib_imports
#| warning: false
#| code-fold: false
library(ggplot2)
library(dplyr)
library(tidyr)
library(gt)
library(tibble)
library(patchwork)
library(FactoMineR)
library(factoextra)
library(ggtext)
library(micEcon)
library(micEconSNQP)
library(micEconIndex)
library(micEconCES)
library(frontier)
library(ranger)
library(tuneRanger)
library(mlr)
library(rsample)
library(forcats)
library(performance)
```

```{r}
#| label: colors
#| echo: false
bg_color <- "#FCFCFC"
alpha <- 0.7
```

```{r}
#| label: theming
#| echo: false
theme_set(theme_minimal())
thematic::thematic_on(bg = "#FCFCFC", fg = "black", accent = "purple", font = "PT Sans")
```

## Description des donn√©es

Le jeu de donn√©es `appleProdFr86` utilis√© dans le papier d'√©conom√©trie de @ivaldi1996 comprend des donn√©es transversales de production de **140** producteurs de pommes fran√ßais datant de l‚Äôann√©e 1986. 

```{r}
#| label: data_import
#| code-fold: false
apples <- readxl::read_excel("data/appleProdFr86.xlsx")
```

{{< include sections/1_desc.qmd >}}

## Statistiques descriptives

{{< include sections/2_stat_desc.qmd >}}

## Analyse exploratoire

{{< include sections/3_acp.qmd >}}

## Fonctions de production

{{< include sections/4_linear_prod_func.qmd >}}

{{< include sections/5_cobb_douglas_prod_func.qmd >}}

{{< include sections/6_quad_prod_func.qmd >}}

{{< include sections/7_translog_prod_func.qmd >}}

{{< include sections/8_sfa_prod_func.qmd >}}

{{< include sections/9_ces_prod_func.qmd >}}

## Fonctions de co√ªt

> Une fonction de co√ªt repr√©sente la relation entre les quantit√©s des diff√©rents facteurs de production utilis√©s (ici `qCap`, `qLab`, `qMat`) et le co√ªt total de production (ici `vCap + vLab + vMat`).

En fait, celle-ci donne le co√ªt minimum associ√© √† un niveau d'output et de prix des inputs, en tenant compte de la technologie disponible.

Calculons d'abord le co√ªt total des inputs, c'est √† dire $v_{Cap} + v_{Lab} + v_{Mat}$.

```{r}
#| label: total_cost
#| code-fold: false
apples <- apples |> mutate(cost = vCap + vLab + vMat)
```

{{< include sections/11_cost_functions.qmd >}}

## Profit des producteurs

$$
\pi = (p_{Out} \cdot q_{Out}) - \overbrace{(v_{Cap} + v_{Lab} + v_{Mat})}^{cost}
$$

```{r}
#| label: profit_formula
#| code-fold: false
apples <- apples |> mutate(profit = (pOut * qOut) - cost)
```

::: {.callout-note}

- Les producteurs dont le profit d√©passe 5 millions sont mis en surbrillance [**verte**]{style="color:darkgreen;"}.

- Les producteurs dont le profit est n√©gatif sont en mis subrillance [**rouge**]{style="color:darkred;"}.

:::

```{r}
#| label: profit_tbl
#| echo: false

profit_tbl <- apples |>
    select(pOut, qOut, cost, profit) |>
    rowid_to_column() |>
    arrange(desc(profit)) |>
    select(rowid, profit)

profit_tbl |>
    gt() |>
    cols_label(
        rowid = md("$N$"),
        profit = md("$\\pi$")
    ) |>
    fmt_number(-rowid, suffixing = TRUE) |>
    fmt_integer(rowid, pattern = "Producteur {x}") |>
    cols_align("center") |>
    tab_header(
        title = md("**Profit des producteurs de pommes**")
    ) |>
    data_color(
        columns = profit,
        rows = profit < 0,
        palette = "darkred",
        alpha = 0.75
    ) |>
    data_color(
        columns = profit,
        rows = profit > 5000000,
        palette = "darkgreen",
        alpha = 0.75
    ) |>
    tab_options(
        table.background.color = bg_color
    ) |>
    opt_interactive(use_highlight = TRUE)
```

```{r}
#| label: profit_metrics
#| echo: false

negative_profit <- profit_tbl |>
    filter(profit < 0) |>
    count() |>
    pull()

five_million_profit <- profit_tbl |>
    filter(profit > 5000000) |>
    count() |>
    pull()

min_profit <- profit_tbl |> filter(profit == min(profit))
max_profit <- profit_tbl |> filter(profit == max(profit))

avg_profit <- profit_tbl |>
    summarise(mean = mean(profit)) |>
    pull() |>
    round(2)

median_profit <- profit_tbl |>
    summarise(median = median(profit)) |>
    pull() |>
    round(2)

min_producer <- min_profit |>
    select(rowid) |>
    pull()
max_producer <- max_profit |>
    select(rowid) |>
    pull()
```

**On remarque tout de m√™me qu'il y a d'importantes diff√©rences de profits entre les producteurs.** 

En effet, il y a **`r negative_profit`** producteurs de pommes ayant un profit n√©gatif et **`r five_million_profit`** producteurs dont le profit est sup√©rieur √† 5 millions.

- Le profit moyen $\bar\pi$ quant √† lui est de **`r format(avg_profit, scientific = F)`**.

- Le profit m√©dian $\tilde\pi$, bien inf√©rieur, est de **`r format(median_profit, scientific = F)`**.

Enfin, le **producteur `r min_producer`** poss√®de le profit le moins elev√© du panel et le **producteur `r max_producer`** poss√®de le profit le plus elev√© *(voir le tableau ci-dessus)*.

```{r}
#| label: pi_median
#| echo: false
pi_med_adv <- apples |>
    filter(adv == 1) |>
    pull(profit) |>
    median()

pi_med_noadv <- apples |>
    filter(adv == 0) |>
    pull(profit) |>
    median()
```

On remarque quelque chose d'int√©ressant : la m√©diane des profits des producteurs recevant des conseils est bien plus √©lev√©e (**`r format(pi_med_adv, scientific = F)`**) que ceux ne recevant pas de conseils (**`r format(pi_med_noadv, scientific = F)`**)

```{r}
#| label: pi_advice
#| echo: false
#| fig-align: center
apples |>
    select(pOut, qOut, cost, profit, adv_chr) |>
    ggplot() +
    aes(y = profit, x = adv_chr, fill = adv_chr) +
    geom_boxplot() +
    labs(
        title = "Profit en fonction de conseils ou non.",
        y = "Profit",
        caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
    ) +
    scale_y_continuous(
        labels = scales::label_number(
            scale_cut = scales::cut_short_scale()
        )
    )
```

> Nous pouvons aussi nous int√©resser au nuage de points des profits et des quantit√©s produites.

```{r}
#| label: qout_profit_corr
#| echo: false
qout_profit_corr <- apples |>
    select(qOut, profit) |>
    cor() |>
    as_tibble() |>
    select(profit) |>
    slice(1) |>
    pull() |>
    round(2)
```

*Note* : Etant donn√© la corr√©lation de **`r qout_profit_corr`** entre `profit` et `qOut`, on s'attend √©videmment √† ce que produire plus de pommes entra√Æne n√©cessairement un acroissement du profit. 

```{r}
#| label: profit_qout
#| fig-align: center
#| echo: false
ggplot(apples, aes(x = qOut, y = profit, color = efficiency)) +
    geom_point() +
    scale_y_continuous(
        labels = scales::label_number(
            scale_cut = scales::cut_short_scale()
        )
    ) +
    scale_x_continuous(
        labels = scales::label_number(
            scale_cut = scales::cut_short_scale()
        )
    ) +
    scale_color_continuous(trans = "reverse") +
    labs(
        x = expression(q[Out]),
        y = expression(pi),
        title = "Relation entre le profit et l'output",
        subtitle = "Les points les plus fonc√©s repr√©sentent les producteurs les plus efficaces techniquement (SFA)",
        caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
    ) +
    theme(legend.position = "none")
```

### Fonction de profit Quadratique Normalis√©e Sym√©trique

Using the netput notation (where outputs are positive and inputs are treated as negative)

```{r}
#| label: snq_experimentation
apples_snq <- apples |>
    select(N, pOut, pCap, pLab, pMat, qOut, qCap, qLab, qMat) |>
    mutate(qCap = -qCap, qLab = -qLab, qMat = -qMat)

snq_func <- snqProfitEst(
    priceNames = c("pOut", "pCap", "pLab", "pMat"),
    quantNames = c("qOut", "qCap", "qLab", "qMat"),
    data = apples_snq,
)

snq_func_convex <- snqProfitImposeConvexity(snq_func)

snq_func_convex

# predict(snq_func_convex)
```

## Co√ªt moyen

Le co√ªt moyen repr√©sente le co√ªt total (`cost`) de la firme divis√© par son niveau d'output (`qOut`).

```{r}
#| label: mean_cost
#| code-fold: false
apples <- apples |> mutate(CM = cost / qOut)
```

```{r}
#| label: mean_cost_study
#| echo: false
#| fig-align: center
qOut_MAX <- 8000000

df_cost <- bind_cols(margCosts, apples |> select(pOut, qOut, cost)) |>
    filter(marg_cost < 10) |>
    filter(qOut < qOut_MAX) |>
    mutate(avg_cost = cost / qOut) |>
    mutate(diff_cost = avg_cost - marg_cost)

cube_ac <- lm(avg_cost ~ qOut + I(qOut^2) + I(qOut^3) + I(qOut^4) + I(qOut^5) + I(qOut^6) + I(qOut^7) + I(qOut^8), df_cost)
coefs <- cube_ac$coefficients

qOut <- seq(0, qOut_MAX, by = 1000)

func_AC <- coefs[1] + coefs[2] * qOut + coefs[3] * qOut^2 + coefs[4] * qOut^3 + coefs[5] * qOut^4 + coefs[6] * qOut^5 + coefs[7] * qOut^6 + coefs[8] * qOut^7 + coefs[9] * qOut^8
datoum2 <- data.frame(qOut = qOut, func_AC = func_AC)
ggplot() +
    geom_line(data = datoum2, aes(x = qOut, y = func_AC), color = "purple", lwd = 1) +
    geom_point(data = df_cost, aes(x = qOut, y = avg_cost), alpha = 0.1, color = "purple") +
    labs(
        x = expression(q[Out]), y = "Co√ªt Moyen", title = "Co√ªt moyen en fonction de qOut",
        caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
    ) +
    scale_x_continuous(
        labels = scales::label_number(
            scale_cut = scales::cut_short_scale()
        )
    )
```

- On constate que le co√ªt moyen diminue consid√©rablement au d√©but de la production, puis se stabilise √† mesure que la quantit√© produite augmente.

***

On peut ensuite analyser la diff√©rence entre le co√ªt marginal et le co√ªt moyen (le co√ªt marginal que nous utilisons est celui calcul√© en Section 5.4.1).

```{r}
#| label: mean_marginal_cost
#| echo: false
#| fig-align: center
ggplot() +
    geom_point(
        data = df_cost, aes(x = qOut, y = diff_cost),
        color = "purple4",
        alpha = 0.5
    ) +
    labs(
        x = expression(q[Out]), y = "Co√ªt Moyen - Co√ªt Marginal",
        title = "Co√ªt Moyen - Co√ªt Marginal en fonction de qOut",
        caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
    ) +
    scale_x_continuous(
        labels = scales::label_number(
            scale_cut = scales::cut_short_scale()
        )
    ) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "red")
```

Selon @harnay, toutes les valeurs n√©gatives d√©montrent donc que les producteurs ont un co√ªt marginal croissant, tandis que si la valeur est positive sur ce graphe, cela signifie que le producteur a un co√ªt marginal d√©croissant. On constate que la majorit√© des producteurs ont un co√ªt marginal d√©croissant.

On peut √©galement tracer les courbes correspondant √† la recette totale (RT) et au co√ªt total (CT). La relation entre RT et la quantit√© produite est estim√©e de mani√®re `quadratique` alors que la relation entre le CT et la quantit√© produite est une relation `lin√©aire`. Les points correspondent aux donn√©es r√©elles. 

```{r}
#| label: pi_study_lines
#| echo: false
#| fig-align: center
qOut_MAX <- 2000000

etude <- apples |>
    filter(qOut < qOut_MAX) |>
    select(pOut, qOut, cost, profit, adv_chr) |>
    mutate(RT = pOut * qOut)

quadra_rt <- lm(RT ~ qOut + I(qOut^2), etude)
quadra_rt_coefs <- quadra_rt$coefficients
linear_ct <- lm(cost ~ qOut, etude)
linear_ct_coefs <- linear_ct$coefficients

qOut <- seq(0, qOut_MAX, by = 1000)
func_RT <- quadra_rt_coefs[1] + quadra_rt_coefs[2] * qOut + quadra_rt_coefs[3] * qOut^2
func_CT <- linear_ct_coefs[1] + linear_ct_coefs[2] * qOut

datoum <- data.frame(qOut = qOut, func_RT = func_RT, func_CT = func_CT)

ggplot() +
    geom_line(data = datoum, aes(x = qOut, y = func_RT), color = "red", lwd = 1) +
    geom_line(data = datoum, aes(x = qOut, y = func_CT), color = "blue", lwd = 1) +
    geom_point(data = etude, aes(x = qOut, y = RT), alpha = 0.1, color = "red") +
    geom_point(data = etude, aes(x = qOut, y = cost), alpha = 0.1, color = "blue") +
    geom_ribbon(
        data = subset(datoum, func_RT > func_CT),
        aes(x = qOut, ymin = func_CT, ymax = func_RT),
        fill = "black", alpha = 0.1
    ) +
    labs(
        x = expression(q[Out]), y = "RT & CT", title = "Etude du profit",
        caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
    ) +
    annotate(
        geom = "text", x = qOut_MAX * 0.95, y = max(func_CT) * 2,
        label = "Profit", color = "black", fontface = "bold"
    ) +
    annotate(
        geom = "text", x = qOut_MAX * 0.95, y = max(func_RT),
        label = "Recette Totale", color = "red"
    ) +
    annotate(
        geom = "text", x = qOut_MAX * 0.95, y = max(func_CT) * 0.65,
        label = "Co√ªt Total", color = "blue"
    ) +
    scale_y_continuous(
        labels = scales::label_number(
            scale_cut = scales::cut_short_scale()
        )
    ) +
    scale_x_continuous(
        labels = scales::label_number(
            scale_cut = scales::cut_short_scale()
        )
    )
```

On constate que le profit est dans un premier temps n√©gatif puis devient positif (partie gris√©e). Ce petit mod√®le permet de constater √† partir de quelle quantit√© produite un arboriculteur commence √† faire du profit.

*On remarque aussi visuellement les rendements d'√©chelle croissants*

[ {{< fa arrow-up-from-bracket >}} Haut de la page](#imports-et-configuration){.btn .btn-outline-primary .btn role="button" .center}