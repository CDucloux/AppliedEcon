---
title: "{{< fa flask >}} **Econom√©trie Appliqu√©e**"
title-block-banner: apples.png
subtitle: "Des üçè sur {{< fa brands r-project >}} !"
toc: true
toc-title: üìö Table des mati√®res
lang: fr
number-sections: true
author:
  - name: "*Corentin Ducloux*"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
  - name: "*Guillaume Devant*"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
date: today
date-format: short
include-in-header: 
    - text: | 
        <link href='https://fonts.googleapis.com/css?family=Fira Code' rel='stylesheet'>
format:
    html:
        theme: simplex
        monofont: "Fira Code"
        fontsize: 1em
        embed-resources: true
        html-math-method: mathjax
        code-fold: show
        anchor-sections: true
        smooth-scroll: true
        citations-hover: true
        footnotes-hover: true
        link-external-icon: true
        link-external-newwindow: true
code-block-bg: "#F1F3F5"
code-block-border-left: "#d9230f"
license: "CC BY-SA"
bibliography: references.bib
crossref:
    eq-prefix: √©quation
    tbl-prefix: Tableau
editor_options: 
  chunk_output_type: console
---

```{css, echo=FALSE}
.title {
    color: white;
}
.subtitle {
    color: white;
}
```

```{r}
#| label: functions

makestars <- function(pvalues) {
    return(
        dplyr::case_when(
            pvalues < 0.001 ~ "$***$",
            pvalues < 0.05 ~ "$**$",
            pvalues < 0.1 ~ "$*$",
            .default = ""
        )
    )
}


gtgazer <- function(model, n_coef = 4, coefnames, description, title, bg_color) {
    coefficients <- summary(model)$coefTable[1:n_coef, 1]
    std_values <- summary(model)$coefTable[1:n_coef, 2]
    pvalues <- summary(model)$coefTable[1:n_coef, 4]
    signif <- makestars(pvalues)
    r2 <- round(summary(model)$r2, 3)
    adj_r2 <- round(summary(model)$r2bar, 3)
    n <- summary(model)$nObs
    dep_variable <- summary(model)$yName
    coefnames <- coefnames
    description <- description
    reg_results <- data.frame(cbind(coefnames, description, coefficients, std_values, pvalues, signif)) |>
        tibble() |>
        mutate(across(c(coefficients, std_values, pvalues), as.numeric))

    table <- reg_results |>
        gt(rowname_col = "coefnames") |>
        cols_label(
            description = md("**Description**"),
            coefficients = md("**Coefficients**"),
            std_values = md("**Ecart Type**"),
            pvalues = md("**Pvalues**"),
            signif = md("**Significativit√©**")
        ) |>
        fmt_markdown(columns = c(coefnames, signif, description)) |>
        fmt_number(columns = c(coefficients, pvalues), decimals = 3) |>
        fmt(columns = std_values, fns = function(std) {
            paste("+/-", round(std, 3))
        }) |>
        tab_footnote(footnote = md(sprintf("*Observations* : %s", n))) |>
        tab_footnote(footnote = md("***")) |>
        tab_footnote(footnote = md(sprintf("$R^2=$ %s", r2))) |>
        tab_footnote(footnote = md(sprintf("$R^2_{adj}=$ %s", adj_r2))) |>
        tab_header(
            title = md(title),
            subtitle = md(sprintf("Variable d√©pendante : *%s*", dep_variable))
        ) |>
        tab_options(
            table.background.color = bg_color
        )

    return(table)
}
```

## Imports

```{r}
#| label: lib_imports
#| warning: false
library(ggplot2)
library(dplyr)
library(readxl)
library(micEcon)
library(stargazer)
library(gt)
library(tibble)
library(knitr)
library(plotly)
library(patchwork)
```

```{r}
#| label : colors
bg_color <- "#FCFCFC"
```

## Description des donn√©es

Le jeu de donn√©es `appleProdFr86` utilis√© dans le papier d'√©conom√©trie de @ivaldi1996 comprend des donn√©es transversales de production de **140** producteurs de pommes fran√ßais datant de l‚Äôann√©e 1986. 

```{r}
#| label: data_import
apples <- read_excel("data/appleProdFr86.xlsx")
```

| Colonnes    | Description                                                                                              |
|-------------|----------------------------------------------------------------------------------------------------------|
| `vCap`      | Co√ªts associ√©s au **capital** *(foncier compris)*.                                                       |
| `vLab`      | Co√ªts associ√©s au **travail** *(y compris la r√©mun√©ration du travail familial non r√©mun√©r√©)*.            |
| `vMat`      | Co√ªts des **mati√®res interm√©diaires** *(plantations, engrais, pesticides, carburant, etc)*.              |
| `qApples`   | Indice de quantit√© des pommes produites.                                                                 |
| `qOtherOut` | Indice de quantit√© de tous les autres outputs.                                                           |
| `qOut`      | Indice de quantit√© de toute la production $\Rightarrow 580000 \cdot (\text{qApples} + \text{qOtherOut})$ |
| `pCap`      | Indice des prix du **capital**.                                                                           |
| `pLab`      | Indice des prix du **travail**.                                                                           |
| `pMat`      | Indice des prix des **mati√®res interm√©diaires**.                                                          |
| `pOut`      | Indice des prix de la production globale.                                                                 |
| `adv`       | Distingue les producteurs qui sont conseill√©s par des laboratoires d'agronomie.                           |

: Descriptif des colonnes {.hover}

### Tableau descriptif

> Ce tableau descriptif retrace les 10 premi√®res observations et l'ensemble des variables associ√©es dans le *dataset*.

```{r}
#| label: descriptive table
apples |>
    head(n = 10) |>
    gt() |>
    tab_header(
        title = md("**Producteurs de pommes üçé**"),
        subtitle = md("*140 producteurs* üá´üá∑ *(1986)*")
    ) |>
    tab_source_note(
        source_note = "Source: Ivaldi et al. (1996)"
    ) |>
    tab_spanner(
        label = "Costs",
        columns = c("vCap", "vLab", "vMat")
    ) |>
    tab_spanner(
        label = "Price Index",
        columns = c("pCap", "pLab", "pMat", "pOut")
    ) |>
    tab_spanner(
        label = "Quantity Index",
        columns = c("qApples", "qOtherOut", "qOut")
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "lavenderblush")
        ),
        location = cells_body(columns = c(vCap, vLab, vMat))
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "ivory")
        ),
        location = cells_body(columns = c(qApples, qOtherOut, qOut))
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "aliceblue")
        ),
        location = cells_body(columns = c(pCap, pLab, pMat, pOut))
    ) |>
    fmt_number(suffixing = TRUE, n_sigfi = 2) |>
    text_case_match(
        "1.0" ~ fontawesome::fa("check"),
        "0" ~ fontawesome::fa("xmark"),
        .locations = cells_body(columns = adv)
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

## Statistiques descriptives

### Productivit√©s moyennes des facteurs de production 

*Pas s√ªr...*

```{r}
prodCap <- (apples$qCap / apples$vCap)
prodLab <- (apples$qLab / apples$vLab)
prodMat <- (apples$qMat / apples$vMat)

prodQCap <- (apples$qOut / apples$vCap)
prodQLab <- (apples$qOut / apples$vLab)
prodQMat <- (apples$qOut / apples$vMat)
```

```{r}
apples |> 
  ggplot() +
  aes(x = prodCap) +
  geom_histogram(binwidth = 0.1, fill = "royalblue", alpha = 0.7) +
  labs(title = "Productivit√© du Capital", x = "Productivit√©", y = "Fr√©quence")
```

```{r}
apples |> 
  ggplot() +
  aes(x = prodLab) +
  geom_histogram(binwidth = 0.05, fill = "darkgreen", alpha = 0.7) +
  labs(title = "Productivit√© du Travail", x = "Productivit√©", y = "Fr√©quence")
```

```{r}
apples |> 
  ggplot() +
  aes(x = prodMat) +
  geom_histogram(binwidth = 0.01, fill = "darkorchid", alpha = 0.7) +
  labs(title = "Productivit√© des mat√©riaux", x = "Productivit√©", y = "Fr√©quence")
```

### Corr√©lations entre les quantit√©s des 3 facteurs de production

```{r}
apples |> 
  select(qCap, qMat, qLab) |> 
  cor() |> 
  round(2) |> 
  data.frame() |> 
  gt() |> 
  tab_header("Matrice de corr√©lation")
```

### Matrice des corr√©lations

```{r}
apples_num <- apples |>
    select(-N)

cor <- apples_num |> cor()

fig <- plot_ly(
    x = colnames(apples_num), y = colnames(apples_num),
    z = cor, type = "heatmap", colors = "Greys"
)
fig
```

### Productivit√©s moyennes

```{r}
CL <- apples |> 
  ggplot()+
  aes(x = prodCap, y = prodLab)+
  geom_point()
ML <- apples |> 
  ggplot()+
  aes(x = prodMat, y = prodLab)+
  geom_point()
CM <- apples |> 
  ggplot()+
  aes(x = prodCap, y = prodMat)+
  geom_point()

CL+ML+CM
```

```{r}
QC <- apples |> 
  ggplot()+
  aes(y = prodQCap, x = prodCap)+
  geom_point()
QL <- apples |> 
  ggplot()+
  aes(y = prodQLab, x = prodLab)+
  geom_point()
QM <- apples |> 
  ggplot()+
  aes(y = prodQMat, x = prodMat)+
  geom_point()

QC+QL+QM
```

### Paasche ou Laspeyeres ou Fisher

### Indice de productivit√© globale des facteurs

```{r}
apples$prod_global <- (apples$qOut) / (apples$vCap + apples$vLab + apples$vMat)
```

```{r}
apples |> 
  ggplot()+
  aes(x = prod_global)+
  geom_histogram(binwidth = 0.25, fill = "darkred", alpha = 0.7)+
  labs(title = "Productivit√© global", x = "Productivit√©", y = "Fr√©quence")
```

```{r}
apples |> 
  ggplot()+
  aes(x = prod_global, fill = as.factor(adv))+
  geom_boxplot()+
  coord_flip()+
  labs(title = "Productivit√© global en fonction conseil ou non")+
  theme(legend.position = "None")
```




## Analyse exploratoire

**ACP √† faire ?** pourrait √™tre int√©ressant

```{r}
apples_num <- apples |>
    select(-N)

cor <- apples_num |> cor()

fig <- plot_ly(x = apples$vCap, type = "histogram", nbinsx = 30, alpha = 0.6)
fig

fig <- plot_ly(alpha = 0.6, nbinsx = 50)
fig <- fig %>% add_histogram(apples$vCap[apples$adv == 1], name = "advisory service")
fig <- fig %>% add_histogram(apples$vCap[apples$adv == 0], name = "not advisory service")
fig <- fig %>% layout(
    barmode = "overlay",
    yaxis = list(title = "Frequency"),
    xaxis = list(title = "Values")
)
fig
```


### Infos sur le sujet
$$
Q = f(QCAP, QLAB, QMAT)\\
$$

il y a aussi les infos sur $C(Q)$

Comparer les productivit√©s des facteurs. (graphiquement) - imaginons que les unit√©s sont des tonnes (combien de tonnes sont produites par unit√© de travail, capital, etc.)

Comment ces productivit√©s individuelles sont corr√©l√©es (entre QCAP, QLAB, QMAT) 

- Indice de Paasche
- Indice de Laspeyres
- Indice de Fisher

Expliquer les diff√©rences de profits entre les producteurs ? Regarder du cot√© des fonctions de profit.

Propri√©t√© de la CD => si la fonction de prod est cobb douglas, alors la fonction de co√ªt l'est aussi.

alpha y => mesure des rendements d'√©chelle...

Pour la question 7, o nint√®gre la quantit√© d'inputs comme variable explicative => fonction de cout de court terme

Fonction de cout qui int√®gre que la quantit√© de capital ne change pas instantan√©ment


Rendements d'√©chelle (somme des exposants) => on peut trouver ces rendements d'√©chelle soit en faisant la fonction de co√ªt, ou la fonction de production. Mais on peut aussi les estimer grace √† une fonction de demande

**DEUX CHOSES ESSENTIELLES**


- Il faut estimer les substitutions entre facteurs
- Les rendements d'√©chelle


Dans la cobb douglas les substitutions entre facteurs il est constant et c'est 1.

Regarder le $\prod$


### Notes sur la translog Cost

On pourrait tt √† fait estimer le syst√®me d'√©quations suivant :

Voir aussi la slide 78 sur la fonction $\ln C$

$$
\begin{cases}
S_1 = \alpha_1 + \sum^3_{i=1} \beta_{1j}\ln p_j + \beta_{1y}\ln y\\
S_2 = \alpha_2 + \sum^3_{i=1} \beta_{2j}\ln p_j + \beta_{2y}\ln y\\
S_3 = \alpha_3 + \sum^3_{i=1} \beta_{3j}\ln p_j + \beta_{3y}\ln y
\end{cases}
$$

Inconv√©nients dans la translog et des formes flexibles : 

Le nombre de param√®tres explose √† cause des effets crois√©s et risque important de collin√©arit√©.

Quand on passe au syst√®me au tableau, on a augment√© √† 3*140 donn√©es (420 observations) et on a un peu moins de param√®tres

```{r}
apples |>
    select(qApples, adv) |>
    group_by(adv) |>
    summarise(mean = mean(qApples))
```

## Fonction Cobb-Douglas

:::{.callout-tip}

## Forme g√©n√©rale d'une fonction Cobb-Douglas

La forme est g√©n√©ralis√©e √† $N$ inputs.

$$y = A \prod_{k=1}^N x_k^{a_k}$$

:::

Dans le cadre de cette √©tude comparative, nous avons 3 *inputs* :

- `qCap` $\Rightarrow$ la quantit√© de capital
- `qLab` $\Rightarrow$ la quantit√© de travail
- `qMat` $\Rightarrow$ la quantit√© de mat√©riaux

Nous obtenons donc la forme suivante :

$$q_{Out} = A\cdot q_{Cap}^\alpha \cdot q_{Lab}^\beta \cdot q_{Mat}^\gamma$$

*Avec $A, \alpha, \beta, \gamma \Rightarrow$ 4 param√®tres √† estimer.*

On peut facilement lin√©ariser la fonction, d√®s lors on obtient :

$$
\ln(q_{out}) = \ln(A) + \alpha \cdot \ln(q_{Cap}) + \beta \cdot \ln(q_{Lab}) + \gamma \cdot \ln(q_{Mat})
$$

Allen Elasticity of Substitution (AES)

$\sigma_{\{\text{qCap, qLab, qMat}\}} = 1$


**Rappel** : Si la fonction de production est **Cobb-Douglas**, alors on a normalement $\hat\alpha + \hat\beta + \hat\gamma = 1$

On peut tester cette hypoth√®se : 

$$
\begin{cases}
H_0 : \alpha + \beta + \gamma = 1\\
H_1 : \alpha + \beta + \gamma \neq 1\\
\end{cases}
$$


```{r}
# Estime une fonction de production Cobb Douglas avec l'argument linear
cd_prod <- translogEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    apples,
    linear = TRUE
)

quad_prod <- quadFuncEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    apples
)

summary(quad_prod$est)

elasticities(cd_prod)
elasticities(quad_prod)
```

```{r}
gtgazer(
    cd_prod,
    n_coef = 4,
    coefnames = c("$A$", "$\\alpha$", "$\\beta$", "$\\gamma$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qCap`",
        "- Coefficient associ√© √† la variable `qLab`",
        "- Coefficient associ√© √† la variable `qMat`"
    ),
    title = "**Fonction de production Cobb-Douglas**",
    bg_color = bg_color
)
```


```{r}
summary(cd_prod$est)
```


```{r}
apples <- apples |> mutate(cost = vCap + vLab + vMat)
```

```{r}
# Estime une fonction Cobb Douglas avec l'argument linear
# translogCostEst("cost", "qOut", c("qCap", "qLab", "qMat"), apples)
```

- Avec la fonction de cout on trouve 2.7 -- √† v√©rifier 

Estimer des fonctions de cout, les rendements d'√©chelle, estimer la fonction CES, la leontieff g√©n√©ralis√©e, calculer le profit des producteurs, lien entre efficacit√©, optimalit√©, v√©rifier h√©t√©rosc√©dasticit√©.

```{r}
cobbDouglasCalc(c("qCap", "qLab", "qMat"), apples, coef(cd_prod)[1:4], coefCov = NULL, dataLogged = FALSE)
```


