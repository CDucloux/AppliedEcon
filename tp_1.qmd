---
title: "{{< fa flask >}} **Econom√©trie Appliqu√©e**"
title-block-banner: apples.png
subtitle: "Des üçè sur {{< fa brands r-project >}} !"
toc: true
toc-title: üìö Table des mati√®res
lang: fr
number-sections: true
author:
  - name: "*Corentin Ducloux*"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
  - name: "*Guillaume Devant*"
    affiliation: 
      - name: Universit√© de Tours
        url: https://www.univ-tours.fr/
date: today
date-format: short
include-in-header: 
    - text: | 
        <link href='https://fonts.googleapis.com/css?family=Fira Code' rel='stylesheet'>
format:
    html:
        theme: simplex
        monofont: "Fira Code"
        fontsize: 1em
        embed-resources: true
        html-math-method: mathjax
        code-fold: true 
        anchor-sections: true
        smooth-scroll: true
        citations-hover: true
        footnotes-hover: true
        link-external-icon: true
        link-external-newwindow: true
code-block-bg: "#F1F3F5"
code-block-border-left: "#d9230f"
license: "CC BY-SA"
bibliography: references.bib
crossref:
    eq-prefix: √©quation
    tbl-prefix: Tableau
editor_options: 
    chunk_output_type: console
---

```{css, echo=FALSE}
.title {
    color: white;
}
.subtitle {
    color: white;
}
```

```{r}
#| label: functions

makestars <- function(pvalues) {
    return(
        dplyr::case_when(
            pvalues < 0.001 ~ "$***$",
            pvalues < 0.05 ~ "$**$",
            pvalues < 0.1 ~ "$*$",
            .default = ""
        )
    )
}


gtgazer <- function(model, n_coef = 4, coefnames, description, title, bg_color) {
    if (class(model) %in% c("translogEst")) {
        coefficients <- summary(model)$coefTable[1:n_coef, 1]
        std_values <- summary(model)$coefTable[1:n_coef, 2]
        pvalues <- summary(model)$coefTable[1:n_coef, 4]
        signif <- makestars(pvalues)
        r2 <- round(summary(model)$r2, 3)
        adj_r2 <- round(summary(model)$r2bar, 3)
        n <- summary(model)$nObs
        dep_variable <- summary(model)$yName
    } else if (class(model) %in% c("quadFuncEst", "translogCostEst")) {
        coefficients <- summary(model$est)$coefficients[, 1]
        std_values <- summary(model$est)$coefficients[, 2]
        pvalues <- summary(model$est)$coefficients[, 4]
        signif <- makestars(pvalues)
        r2 <- round(model$r2, 3)
        adj_r2 <- round(model$r2bar, 3)
        n <- model$nObs
        dep_variable <- ifelse(class(model) == "quadFuncEst", model$yName, model$cName)
    }

    coefnames <- coefnames
    description <- description
    reg_results <- data.frame(cbind(coefnames, description, coefficients, std_values, pvalues, signif)) |>
        tibble() |>
        mutate(across(c(coefficients, std_values, pvalues), as.numeric))

    table <- reg_results |>
        gt(rowname_col = "coefnames") |>
        cols_label(
            description = md("**Description**"),
            coefficients = md("**Coefficients**"),
            std_values = md("**Ecart Type**"),
            pvalues = md("**Pvalues**"),
            signif = md("**Significativit√©**")
        ) |>
        fmt_markdown(columns = c(coefnames, signif, description)) |>
        fmt_number(columns = c(coefficients, pvalues), decimals = 3) |>
        fmt(columns = std_values, fns = function(std) {
            paste("+/-", round(std, 3))
        }) |>
        tab_footnote(footnote = md(sprintf("*Observations* : %s", n))) |>
        tab_footnote(footnote = md("***")) |>
        tab_footnote(footnote = md(glue::glue("$R^2=$ {r2}"))) |>
        tab_footnote(footnote = md(glue::glue("$R^2_{{adj}}=$ {adj_r2}"))) |>
        tab_header(
            title = md(title),
            subtitle = md(glue::glue("Variable d√©pendante : {dep_variable}"))
        ) |>
        tab_options(
            table.background.color = bg_color
        )

    return(table)
}
```

## Imports et configuration

:::{.callout-note}

Tout au long de ce projet, nous utiliserons l'approche [`tidy`](https://www.tidyverse.org/) d√©velopp√©e par @wickham2014 plut√¥t que l'approche `base R` pour manipuler nos donn√©es.

:::


```{r}
#| label: lib_imports
#| warning: false
#| code-fold: false
library(ggplot2)
library(dplyr)
library(readxl)
library(micEcon)
library(gt)
library(tibble)
library(patchwork)
library(showtext)
library(FactoMineR)
library(factoextra)
library(ggtext)
library(micEconIndex)
```

```{r}
#| label: colors
#| echo: false
bg_color <- "#FCFCFC"
alpha <- 0.7
```

```{r}
#| label: theming
#| echo: false
theme_set(theme_minimal())
thematic::thematic_on(bg = "#FCFCFC", fg = "black", accent = "purple", font = "PT Sans")
```

## Description des donn√©es

Le jeu de donn√©es `appleProdFr86` utilis√© dans le papier d'√©conom√©trie de @ivaldi1996 comprend des donn√©es transversales de production de **140** producteurs de pommes fran√ßais datant de l‚Äôann√©e 1986. 

```{r}
#| label: data_import
#| code-fold: false
apples <- read_excel("data/appleProdFr86.xlsx")
```

| Colonnes    | Description                                                                                              |
|-------------|----------------------------------------------------------------------------------------------------------|
| `vCap`      | Co√ªts associ√©s au **capital** *(foncier compris)*.                                                       |
| `vLab`      | Co√ªts associ√©s au **travail** *(y compris la r√©mun√©ration du travail familial non r√©mun√©r√©)*.            |
| `vMat`      | Co√ªts des **mati√®res interm√©diaires** *(plantations, engrais, pesticides, carburant, etc)*.              |
| `qApples`   | Indice de quantit√© des pommes produites.                                                                 |
| `qOtherOut` | Indice de quantit√© de tous les autres outputs.                                                           |
| `qOut`      | Indice de quantit√© de toute la production $\Rightarrow 580000 \cdot (\text{qApples} + \text{qOtherOut})$ |
| `pCap`      | Indice des prix du **capital**.                                                                           |
| `pLab`      | Indice des prix du **travail**.                                                                           |
| `pMat`      | Indice des prix des **mati√®res interm√©diaires**.                                                          |
| `pOut`      | Indice des prix de la production globale.                                                                 |
| `adv`       | Distingue les producteurs qui sont conseill√©s par des laboratoires d'agronomie.                           |

: Descriptif des colonnes {.hover}

### Tableau descriptif

> Ce tableau descriptif retrace les 10 premi√®res observations et l'ensemble des variables associ√©es dans le *dataset*.

```{r}
#| label: descriptive table
#| echo: false
apples |>
    head(n = 10) |>
    gt() |>
    tab_header(
        title = md("**Producteurs de pommes üçé**"),
        subtitle = md("*140 producteurs* üá´üá∑ *(1986)*")
    ) |>
    tab_source_note(
        source_note = md(
            "`Source`: *Ivaldi et al. (1996)*"
        )
    ) |>
    tab_spanner(
        label = "Costs",
        columns = c("vCap", "vLab", "vMat")
    ) |>
    tab_spanner(
        label = "Price Index",
        columns = c("pCap", "pLab", "pMat", "pOut")
    ) |>
    tab_spanner(
        label = "Quantity Index",
        columns = c("qApples", "qOtherOut", "qOut")
    ) |>
    tab_spanner(
        label = "Factor Quantities",
        columns = c("qCap", "qLab", "qMat")
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "lavenderblush")
        ),
        location = cells_body(columns = c(vCap, vLab, vMat))
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "ivory")
        ),
        location = cells_body(columns = c(qApples, qOtherOut, qOut))
    ) |>
    tab_style(
        style = list(
            cell_fill(color = "aliceblue")
        ),
        location = cells_body(columns = c(pCap, pLab, pMat, pOut))
    ) |>
    fmt_number(suffixing = TRUE, n_sigfi = 2) |>
    text_case_match(
        "1.0" ~ fontawesome::fa("check"),
        "0" ~ fontawesome::fa("xmark"),
        .locations = cells_body(columns = adv)
    ) |>
    cols_label(
        N = md("$N$"),
        vCap = md("$v_{Cap}$"),
        vLab = md("$v_{Lab}$"),
        vMat = md("$v_{Mat}$"),
        qApples = md("$q_{Apples}$"),
        qOtherOut = md("$q_{OtherOut}$"),
        qOut = md("$q_{Out}$"),
        pCap = md("$p_{Cap}$"),
        pLab = md("$p_{Lab}$"),
        pMat = md("$p_{Mat}$"),
        pOut = md("$p_{Out}$"),
        adv = md("$adv$"),
        qCap = md("$q_{Cap}$"),
        qLab = md("$q_{Lab}$"),
        qMat = md("$q_{Mat}$")
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

## Statistiques descriptives

### Productivit√© moyenne des facteurs de production {#sec-ap-prod}

La productivit√© moyenne ($AP =$ **Average Product**) consiste √† diviser la quantit√© totale d'output par la quantit√© totale de facteur utilis√© *(input)* dans le processus de production.

Imaginons que les unit√©s d'output sont des tonnes. Pour chaque input, cela revient en fait √† expliquer combien de tonnes sont produites par unit√© de capital, de travail et de mati√®res interm√©diaires en 1986 pour chaque producteur de pommes.

Nous obtenons alors respectivement :

- $AP_{Cap} = \frac{q_{Out}}{q_{Cap}}$

- $AP_{Lab} = \frac{q_{Out}}{q_{Lab}}$

- $AP_{Mat} = \frac{q_{Out}}{q_{Mat}}$


```{r}
#| label: productivites
#| code-fold: false
apples <- apples |> mutate(
    AP_Cap = qOut / qCap,
    AP_Lab = qOut / qLab,
    AP_Mat = qOut / qMat
)
```

```{r}
#| label: table_AP
#| echo: false
tibble_AP_Cap <- apples |>
    summarise(min = min(AP_Cap), mean = mean(AP_Cap), max = max(AP_Cap), std = sd(AP_Cap)) |>
    add_column(type = "$AP_{Cap}$", .before = "min")
tibble_AP_Lab <- apples |>
    summarise(min = min(AP_Lab), mean = mean(AP_Lab), max = max(AP_Lab), std = sd(AP_Lab)) |>
    add_column(type = "$AP_{Lab}$", .before = "min")
tibble_AP_Mat <- apples |>
    summarise(min = min(AP_Mat), mean = mean(AP_Mat), max = max(AP_Mat), std = sd(AP_Mat)) |>
    add_column(type = "$AP_{Mat}$", .before = "min")

AP_table <- bind_rows(tibble_AP_Cap, tibble_AP_Lab, tibble_AP_Mat)

AP_table |>
    gt() |>
    fmt_markdown(columns = type) |>
    fmt_number(columns = c(-type)) |>
    tab_header(
        title = md("**Productivit√© Moyenne par Facteur üìã**"),
        subtitle = md("*Capital --- Travail --- Mat√©riaux*")
    ) |>
    cols_label(
        min = md("$\\min$"),
        mean = md("$\\mu$"),
        max = md("$\\max$"),
        std = md("$\\sigma^2$"),
        type = ""
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

Ce tableau, en plus des visualisations qui vont suivre, permet d'√©tablir que les productivit√©s moyennes par facteur sont **tr√®s diff√©rentes selon les producteurs**. De plus, on s'aper√ßoit aussi qu'investir dans un facteur particulier peut √™tre plus int√©ressant qu'un autre. 

C'est particuli√®rement vrai pour le facteur `Mat` avec une productivit√© moyenne minimale de **8.22** unit√©s d'output pour une unit√© de mat√©riaux et jusqu'√† **301.43** unit√©s d'output pour une unit√© de mat√©riaux.

```{r}
#| label: AP_plots
#| echo: false
#| fig-align: center
apples |>
    ggplot() +
    aes(x = AP_Cap) +
    geom_histogram(binwidth = 1.25, fill = "darkgreen", alpha = alpha) +
    labs(title = "Productivit√© Moyenne du Capital", subtitle = "Pour une unit√© de capital, combien d'unit√©s d'output sont produits ?", x = "", y = "Fr√©quence")

apples |>
    ggplot() +
    aes(x = AP_Lab) +
    geom_histogram(binwidth = 0.75, fill = "orange", alpha = alpha) +
    labs(title = "Productivit√© Moyenne du Travail", subtitle = "Pour une unit√© de travail, combien d'unit√©s d'output sont produits ?", x = "", y = "Fr√©quence")

apples |>
    ggplot() +
    aes(x = AP_Mat) +
    geom_histogram(binwidth = 1.5, fill = "darkorchid", alpha = alpha) +
    labs(title = "Productivit√© Moyenne des mat√©riaux", subtitle = "Pour une unit√© de mat√©riaux, combien d'unit√©s d'output sont produits ?", x = "", y = "Fr√©quence")
```

### Corr√©lations entre les quantit√©s des 3 facteurs de production

```{r}
#| label: q_matrix
#| echo: false
apples |>
    select(qCap, qLab, qMat) |>
    cor() |>
    round(2) |>
    data.frame() |>
    gt() |>
    tab_header(title = md("**Matrice de corr√©lation**")) |>
    cols_add(type = c("$q_{Cap}$", "$q_{Lab}$", "$q_{Mat}$")) |>
    cols_move_to_start(columns = type) |>
    fmt_markdown(type) |>
    cols_label(
        type = "",
        qCap = md("$q_{Cap}$"),
        qLab = md("$q_{Lab}$"),
        qMat = md("$q_{Mat}$"),
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

- Les quantit√©s des 3 facteurs de production sont toutes corr√©l√©es positivement.

- On s'aper√ßoit que la corr√©lation **positive** la plus importante est entre $q_{Lab}$ et $q_{Mat}$ $\Rightarrow$ cela implique que lorsque la quantit√© de travail augmente, la quantit√© de mat√©riaux a tendance √† augmenter dans un niveau tr√®s similaire, et *vice versa*.

### Corr√©lations entre les productivit√©s moyennes

Essayons maintenant de comprendre comment les productivit√©s moyennes individuelles sont corr√©l√©es :

```{r}
#| label: ap_matrix
#| echo: false
apples |>
    select(starts_with("AP")) |>
    cor() |>
    round(2) |>
    data.frame() |>
    gt() |>
    tab_header(title = md("**Matrice de corr√©lation**")) |>
    cols_add(type = c("$AP_{Cap}$", "$AP_{Lab}$", "$AP_{Mat}$")) |>
    cols_move_to_start(columns = type) |>
    fmt_markdown(type) |>
    cols_label(
        type = "",
        AP_Cap = md("$AP_{Cap}$"),
        AP_Lab = md("$AP_{Lab}$"),
        AP_Mat = md("$AP_{Mat}$")
    ) |>
    tab_options(
        table.background.color = bg_color
    )
```

- Ces r√©sultats nous sugg√®rent l'existence de relations positives entre les productivit√©s moyennes des diff√©rents facteurs de production dans le processus de production. 

- Ici, une augmentation de la productivit√© moyenne du travail peut √™tre associ√©e √† une augmentation **significative** de la productivit√© moyenne des mat√©riaux, ce qui peut √™tre d√ª √† des facteurs tels que des processus de production plus efficaces ou une meilleure utilisation des ressources de la part du producteur de pommes.

***


```{r}
#| label: prod_plots
#| echo: false
#| fig-align: center
CL <- apples |>
    ggplot() +
    aes(x = AP_Cap, y = AP_Lab) +
    geom_point(colour = "slategray", alpha = alpha) +
    labs(x = expression(AP[Cap]), y = expression(AP[Lab]))
ML <- apples |>
    ggplot() +
    aes(x = AP_Mat, y = AP_Lab) +
    geom_point(colour = "gray", alpha = alpha) +
    labs(x = expression(AP[Mat]), y = expression(AP[Lab]))
CM <- apples |>
    ggplot() +
    aes(x = AP_Cap, y = AP_Mat) +
    geom_point(colour = "gray21", alpha = alpha) +
    labs(x = expression(AP[Cap]), y = expression(AP[Mat]))

prod_plots <- (CL + ML) / CM

prod_plots + plot_annotation(
    title = "Croisement des productivit√©s moyennes",
    subtitle = "Quelles sont les relations existantes entre les diff√©rentes productivit√©s moyennes ?",
    caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
)
```

::: {.callout-note}

Les repr√©sentations des productivit√©s moyennes $AP_{Cap}$, $AP_{Lab}$ et $AP_{Mat}$ par rapport √† l'output $q_{Out}$ peuvent aussi √™tre tr√®s utiles pour comprendre les relations entre la production totale et l'utilisation des diff√©rents facteurs de production.

:::

```{r}
#| label: qout_plots
#| echo: false
#| fig-align: center
QC <- apples |>
    ggplot() +
    aes(y = qOut, x = AP_Cap) +
    geom_point(colour = "darkgreen", alpha = alpha) +
    labs(x = expression(AP[Cap]), y = "")
QL <- apples |>
    ggplot() +
    aes(y = qOut, x = AP_Lab) +
    geom_point(colour = "orange", alpha = alpha) +
    labs(x = expression(AP[Lab]), y = "")
QM <- apples |>
    ggplot() +
    aes(y = qOut, x = AP_Mat) +
    geom_point(colour = "darkorchid", alpha = alpha) +
    labs(x = expression(AP[Mat]), y = "")

qOut_prod_plots <- (QC + QL) / QM

qOut_prod_plots + plot_annotation(
    title = "Productivit√© moyenne par rapport √† l'output total",
    subtitle = "Quelles sont les relations existantes entre les productivit√©s moyennes des inputs et de l'output ?",
    caption = "Auteurs : @Corentin DUCLOUX, @Guillaume DEVANT, 2024 "
)
```

- Les valeurs extr√™mes dans ces nuages de points nous permettent de distinguer ais√©ment les producteurs *efficaces* et *inefficaces* dans l'utilisation des ressources.

### Indices de Paasche, Laspeyres et Fisher

Les productivit√©s moyennes nous donnent une indication facteur par facteur, mais elles ne nous donnent pas n√©cessairement d'information **globale**. Dans ce cadre, on peut alors se demander comment agr√©ger des quantit√©s avec une r√®gle *ad hoc* en un indice synth√©tique.

**3 Indices principaux existent**

::: {.callout-tip}

## Indice de *Paasche*

$$
\text{Paasche}_{index} = \frac{(v_{Cap} + v_{Lab} + v_{Mat})}{{\bar{q}_{Cap}}\cdot p_{Cap} + \bar{q}_{Lab}\cdot p_{Lab} + \bar{q}_{Mat} \cdot p_{Mat}}
$$

:::

::: {.callout-tip}

## Indice de *Laspeyres*

$$
\text{Laspeyres}_{index} = \frac{(q_{Cap} \cdot \bar{p}_{Cap} + q_{Lab} \cdot \bar{p}_{Lab} + q_{Mat} \cdot \bar{p}_{Mat})}{(\bar{q}_{Cap}\cdot \bar{p}_{Cap}+\bar{q}_{Lab}\cdot \bar{p}_{Lab}+\bar{q}_{Mat}\cdot \bar{p}_{Mat})}
$$

:::

::: {.callout-tip}

## Indice de *Fisher*

$$
\text{Fisher}_{index} = \sqrt{\text{Paasche}_{index} \cdot \text{Laspeyres}_{index}}
$$

:::

De plus, la fonction `quantityIndex` du package `micEconIndex` a l'int√©r√™t de facilement int√©grer les calculs de chaque indice *(Voir ci-dessous)*.

```{r}
#| label: q_index
#| code-fold: false
apples <- apples |> mutate(
    L_Index = quantityIndex(
        prices = c("pCap", "pLab", "pMat"),
        quantities = c("qCap", "qLab", "qMat"),
        data = apples,
        method = "Laspeyres"
    ),
    P_Index = quantityIndex(
        prices = c("pCap", "pLab", "pMat"),
        quantities = c("qCap", "qLab", "qMat"),
        data = apples,
        method = "Paasche"
    ),
    F_Index = quantityIndex(
        prices = c("pCap", "pLab", "pMat"),
        quantities = c("qCap", "qLab", "qMat"),
        data = apples,
        method = "Fisher"
    )
)
```

```{r}
#| label: q_index_plots
#| echo: false
#| fig-align: center
apples |>
    ggplot() +
    aes(x = P_Index, y = L_Index) +
    geom_point() +
    geom_smooth(method = lm, se = FALSE) +
    labs(
        x = "Paasche Index",
        y = "Laspeyres Index",
        title = "Relation entre Paasche & Laspeyres & Fisher",
        caption = "Point Size : Fisher index value"
    ) +
    theme(legend.position = "None")
```

***

```{r}
#| label: f_index_matrix
#| echo: false
apples |>
    select(AP_Cap, AP_Lab, AP_Mat, F_Index) |>
    cor() |>
    round(2) |>
    data.frame() |>
    gt() |>
    tab_header(md("**Matrice de corr√©lation**")) |>
    tab_style(
        style = list(
            cell_fill(color = "gray95")
        ),
        locations = cells_body(columns = F_Index)
    ) |>
    cols_add(
        type = c("$AP_{Cap}$", "$AP_{Lab}$", "$AP_{Mat}$", "$\\text{Fisher}_{index}$")
    ) |>
    cols_move_to_start(columns = type) |>
    fmt_markdown(type) |>
    cols_label(
        type = "",
        AP_Cap = md("$AP_{Cap}$"),
        AP_Lab = md("$AP_{Lab}$"),
        AP_Mat = md("$AP_{Mat}$"),
        F_Index = md("$\\text{Fisher}_{index}$")
    ) |>
    tab_style(
        style = cell_fill(color = "gray95"),
        locations = cells_body(rows = c(4))
    )
```

- Ces r√©sultats sugg√®rent que l'indice de *Fisher* n'est pas fortement corr√©l√© avec les productivit√©s moyennes individuelles des facteurs de production.

### Indice de productivit√© globale des facteurs

- Dans la section pr√©c√©dente, nous avons montr√© que les indices donnaient sensiblement les m√™mes r√©sultats. Nous avons n√©anmoins choisi en tant qu'indice de productivit√© globale des facteurs l'indice de *Fisher*, √©tant donn√© qu'il est une moyenne g√©om√©trique de l'indice de *Paasche* et de celui de *Laspeyres*.

```{r}
#| label: f_index_hist
#| echo: false
#| fig-align: center
apples |>
    ggplot() +
    aes(x = F_Index) +
    geom_histogram(binwidth = 0.25, fill = "darkred", alpha = 0.7) +
    labs(title = "Productivit√© globale (Indice de Fisher)", x = "Valeur de l'indice", y = "Fr√©quence")
```

- De mani√®re int√©ressante, contrairement aux histogrammes des productivit√©s moyennes de la @sec-ap-prod, la plupart des valeurs que prend l'indice de *Fisher* sont plus concentr√©es.

```{r}
#| label: f_index_plots
#| echo: false
#| fig-align: center
apples |>
    ggplot() +
    aes(y = qOut, x = F_Index) +
    geom_point(colour = "darkorchid", alpha = alpha) +
    labs(title = "Relation entre l'indice de productivit√© globale des facteurs et l'output", y = "")
```

::: {.callout-note}

La variable dichotomique `adv` pr√©sente dans notre *dataset* est d√©finie par :

$$
adv = 
\begin{cases}
0 \text{ si le producteur n'est pas conseill√©}\\
1 \text{ si le producteur est conseill√©}
\end{cases}
$$

On pourrait penser que les producteurs qui ont √©t√© conseill√©s par des laboratoires d'agronomie ont un indice de productivit√© globale plus important que ceux qui ne l'ont pas √©t√©. 

**V√©rifions-le graphiquement et statistiquement**

:::

```{r}
#| label: advice_boxplot
#| echo: false
apples <- apples |> mutate(
    adv_chr = case_when(
        adv == 0 ~ "No advice",
        adv == 1 ~ "Advice",
    )
)

apples |>
    ggplot() +
    aes(y = F_Index, x = adv_chr, fill = adv_chr) +
    geom_boxplot() +
    labs(title = "Productivit√© globale en fonction du conseil ou non d'un laboratoire", x = "", y = "") +
    theme(legend.position = "None")

apples_grouped <- apples |>
    select(adv_chr, F_Index) |>
    group_by(adv_chr) |>
    summarise(mean = mean(F_Index))

mean_advice <- apples_grouped |>
    slice(1) |>
    pull()

mean_no_advice <- apples_grouped |>
    slice(2) |>
    pull()
```

- En moyenne, il semble ne pas y avoir de diff√©rence de productivit√© globale lorsque le producteur est conseill√©. La productivit√© moyenne avec conseil est `r round(mean_advice,2)` et la productivit√© moyenne sans conseil est quant √† elle `r round(mean_no_advice,2)`.

On peut aussi s'assurer que les moyennes sont significativement diff√©rentes en faisant un test de *Student* bilat√©ral :

$$
\begin{cases}
H_0:\mu_{advice} =\mu_{no\_advice}\\
H_1:\mu_{advice} \neq\mu_{no\_advice}
\end{cases}
$$


```{r}
#| label: advice_ttest
#| echo: false
advice <- apples |>
    select(adv_chr, F_Index) |>
    filter(adv_chr == "Advice") |>
    pull()

no_advice <- apples |>
    select(adv_chr, F_Index) |>
    filter(adv_chr == "No advice") |>
    pull()

t_test <- t.test(advice, no_advice, var.equal = F)
pval_t_test <- t_test$p.value
```

$\Rightarrow$ Au risque $\alpha = 5\%$, la $p-value =$ `r  round(pval_t_test,2)` $> 0.05$, **on conserve donc l'hypoth√®se nulle $H_0$**.


## Analyse exploratoire

```{r}
#| label: pca_biplot
#| echo: false
#| fig-align: center
apples_pca <- apples[-c(96, 129), ] |> select(-c(N, adv_chr))

# On retire les individus 96 et 129 de l'ACP

acp <- PCA(apples_pca, graph = FALSE)

fviz_screeplot(
    acp,
    ylab = "",
    barfill = "royalblue",
    barcolor = "royalblue"
)

contrib_ax_1 <- fviz_contrib(
    acp,
    choice = "var",
    axes = 1,
    fill = "royalblue",
    color = "royalblue"
)

contrib_ax_2 <- fviz_contrib(
    acp,
    choice = "var",
    axes = 2,
    fill = "royalblue",
    color = "royalblue"
)

contrib_ax_1 + contrib_ax_2

fviz_pca_biplot(acp,
    repel = TRUE,
    title = "ACP - Biplot",
    label = "var",
    col.var = "royalblue",
    col.ind = "orange",
    axes = c(1, 2)
)
```

- **Axe 1** $\Rightarrow$ Combinaison de variables : synth√©thise les indices de *Fisher*, *Paasche* et *Laspeyres*, ainsi que les quantit√©s et les co√ªts des 3 facteurs de production.

- **Axe 2** $\Rightarrow$ Productivit√©s moyennes.

**TODO : Customiser les couleurs de contributions et des inerties et tout**

```{r}
#| label: norm_density
#| echo: false
#| fig-align: center
# https://r-charts.com/distribution/histogram-density-ggplot2/
apples |>
    ggplot(aes(x = log(qOut))) +
    geom_histogram(aes(y = after_stat(density)),
        alpha = 0.6,
        bins = 25,
        fill = "royalblue",
        color = "royalblue"
    ) +
    labs(
        x = "log()",
        y = "Fr√©quence"
    ) +
    theme(plot.title = element_markdown(face = "bold", size = 15)) +
    ggtitle("Densit√© <span style='color:royalblue'>log(qOut)</span> vs. <span style='color:darkred'>loi normale</span>") +
    geom_density(
        color = "royalblue",
        linewidth = 1
    ) +
    stat_function(
        fun = dnorm,
        args = list(
            mean = mean(log(apples$qOut)),
            sd = sd(log(apples$qOut))
        ),
        color = "darkred",
        linewidth = 1
    )
```

> Le test de normalit√© confirme statistiquement le fait que les donn√©es `log(qOut)` suivent une distribution normale (p.value > 0.05)

```{r}
shapiro.test(log(apples$qOut))
```

## Fonction de production lin√©aire

:::{.callout-tip}

## Forme de la fonction

$$
q_i = \alpha + \sum_{k=1}^3\beta_k x_{ik} + Œµ_i
$$

- La **fonction de production lin√©aire** dans notre cas s'√©crit donc sous la forme :

$$
q_{Out} = \alpha + \beta_1 q_{Cap} + \beta_2 q_{Lab} + \beta_3 q_{Mat} + Œµ_i
$$

:::

On a pu constater un lien ind√©niable entre la quantit√© produite (`qOut`) et les productivit√©s moyennes. On peut alors l√©gitimement penser qu'il y a une relation entre la quantit√© produite et les quantit√©s des facteurs de production. On peut effectuer une r√©gression lin√©aire pour observer cette relation.

La relation lin√©aire est significative entre `qOut` et les variables explicatives `qMat` et `qLab.` Le $R^2$, sup√©rieur √† 0.78, d√©montre la bonne qualit√© de la r√©gression. De ce mod√®le on peut dire que la quantit√© produite d√©pend principalement de la quanit√© de travail et de mati√®re premi√®re engag√©.

```{r}
linreg_prod <- lm(qOut ~ qMat + qLab + qCap, data = apples)
stargazer::stargazer(linreg_prod, type = "text")
```

**TODO : V√©rifier les r√©sidus**

```{r}
# gtgazer(
#    linreg_prod,
#    n_coef = 4,
#    coefnames = c("$A$", "$\\alpha$", "$\\beta$", "$\\gamma$"),
#    description = c(
#        "- Constante du mod√®le",
#        "- Coefficient associ√© √† la variable `qCap`",
#        "- Coefficient associ√© √† la variable `qLab`",
#        "- Coefficient associ√© √† la variable `qMat`"
#    ),
#    title = "**Fonction de production lin√©aire**",
#    bg_color = bg_color
# )
```

## Fonction Cobb-Douglas

:::{.callout-tip}

## Forme de la fonction

$$
q_i = A \prod_{k=1}^3 x_{ik}^{a_k}Œµ_i
$$

- La **fonction de production Cobb-Douglas** dans notre cas s'√©crit donc sous la forme :

$$
q_{Out} = A\cdot q_{Cap}^\alpha \cdot q_{Lab}^\beta \cdot q_{Mat}^\gamma \cdot Œµ_i
$$

:::

Dans le cadre de cette √©tude comparative, nous avons 3 *inputs* :

- `qCap` $\Rightarrow$ la quantit√© de capital
- `qLab` $\Rightarrow$ la quantit√© de travail
- `qMat` $\Rightarrow$ la quantit√© de mat√©riaux

Nous obtenons donc la forme suivante :

*Avec $A, \alpha, \beta, \gamma \Rightarrow$ 4 param√®tres √† estimer.*

On peut facilement lin√©ariser la fonction, d√®s lors on obtient :

$$
\ln(q_{out}) = \ln(A) + \alpha \cdot \ln(q_{Cap}) + \beta \cdot \ln(q_{Lab}) + \gamma \cdot \ln(q_{Mat}) +  \ln{(Œµ_i)}
$$

Allen Elasticity of Substitution (AES)

$\sigma_{\{\text{qCap, qLab, qMat}\}} = 1$


**Rappel** : Si la fonction de production est **Cobb-Douglas**, alors on a normalement $\hat\alpha + \hat\beta + \hat\gamma = 1$

On peut tester cette hypoth√®se : 

$$
\begin{cases}
H_0 : \alpha + \beta + \gamma = 1\\
H_1 : \alpha + \beta + \gamma \neq 1\\
\end{cases}
$$


```{r}
# Estime une fonction de production Cobb Douglas avec l'argument linear
cd_prod <- translogEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    apples,
    linear = TRUE
)

# elasticities(cd_prod)
# elasticities(quad_prod)
```

```{r}
gtgazer(
    cd_prod,
    n_coef = 4,
    coefnames = c("$A$", "$\\alpha$", "$\\beta$", "$\\gamma$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qCap`",
        "- Coefficient associ√© √† la variable `qLab`",
        "- Coefficient associ√© √† la variable `qMat`"
    ),
    title = "**Fonction de production Cobb-Douglas**",
    bg_color = bg_color
)
```


```{r}
summary(cd_prod$est)
```



## Fonction de production quadratique


:::{.callout-tip}

## Forme de la fonction

$$
q_i = \alpha + \sum_{k=1}^3\beta_k x_{ik} + \frac{1}{2}\sum_{l=1}^3\sum_{k=1}^3 \beta_{kl}x_{ik}x_{il} + Œµ_i
$$

$$
\begin{gathered}q_{Out}‚Äã=Œ±+Œ≤_1‚Äãq_{Cap}‚Äã+Œ≤_2‚Äãq_{Lab}‚Äã+Œ≤_3‚Äãq_{Mat}\\
‚Äã+\frac{1}{2}‚Äã(Œ≤_{11}‚Äãq^2_{Cap}‚Äã+Œ≤_{22}‚Äãq^2_{Lab}‚Äã+Œ≤_{33}‚Äãq^2_{Mat})\\
‚Äã+\frac{1}{2}‚Äã(2Œ≤_{12}‚Äãq_{Cap}‚Äãq_{Lab}‚Äã+2Œ≤_{13}‚Äãq_{Cap}‚Äãq_{Mat}‚Äã+2Œ≤_{23}‚Äãq_{Lab}‚Äãq_{Mat}‚Äã)+Œµ_i‚Äã
\end{gathered}
$$

:::

- $3^2 = 9$ coefficients √† estimer !

```{r}
quad_prod <- quadFuncEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    apples
)
```

```{r}
gtgazer(
    quad_prod,
    n_coef = 9,
    coefnames = c("$A$", "$\\beta_1$", "$\\beta_2$", "$\\beta_3$", "$\\beta_{11}$", "$\\beta_{12}$", "$\\beta_{13}$", "$\\beta_{22}$", "$\\beta_{23}$", "$\\beta_{33}$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qCap`",
        "- Coefficient associ√© √† la variable `qLab`",
        "- Coefficient associ√© √† la variable `qMat`",
        "- Coefficient associ√© √† la variable `qCap¬≤`",
        "- Coefficient associ√© √† la variable `qCap√óqLab`",
        "- Coefficient associ√© √† la variable `qCap√óqMat`",
        "- Coefficient associ√© √† la variable `qLab¬≤`",
        "- Coefficient associ√© √† la variable `qLab√óqMat`",
        "- Coefficient associ√© √† la variable `qMat¬≤`"
    ),
    title = "**Fonction de production quadratique**",
    bg_color = bg_color
)
```

```{r}
summary(quad_prod$est)
```

## Fonction de production Translog
:::{.callout-tip}

## Forme de la fonction

$$
\begin{gathered} ln(q_i) = \alpha + \sum_{k=1}^3\beta_kln(x_{ik})  \\ + \frac{1}{2}\sum_{l=1}^3\sum_{k=1}^3 \beta_{kl}ln(x_{ik})ln(x_{il}) + Œµ_i
\end{gathered}
$$
:::

```{r}
translog_prod <- translogEst(
    "qOut",
    c("qCap", "qLab", "qMat"),
    apples
)
```

```{r}
summary(translog_prod)
```

```{r}
gtgazer(
    translog_prod,
    n_coef = 9,
    coefnames = c("$A$", "$\\beta_1$", "$\\beta_2$", "$\\beta_3$", "$\\beta_{11}$", "$\\beta_{12}$", "$\\beta_{13}$", "$\\beta_{22}$", "$\\beta_{23}$", "$\\beta_{33}$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qCap`",
        "- Coefficient associ√© √† la variable `qLab`",
        "- Coefficient associ√© √† la variable `qMat`",
        "- Coefficient associ√© √† la variable `qCap¬≤`",
        "- Coefficient associ√© √† la variable `qCap√óqLab`",
        "- Coefficient associ√© √† la variable `qCap√óqMat`",
        "- Coefficient associ√© √† la variable `qLab¬≤`",
        "- Coefficient associ√© √† la variable `qLab√óqMat`",
        "- Coefficient associ√© √† la variable `qMat¬≤`"
    ),
    title = "**Fonction de production Translog**",
    bg_color = bg_color
)
```


## Fonction de co√ªt Cobb Douglass
:::{.callout-tip}

## Forme de la fonction
$$
c_i = A \prod_{k=1}^{3} p_{ik}^{\alpha_k}q_i^{\alpha_y} \epsilon_i
$$

:::

```{r}
apples$cost <- apples$vCap + apples$vLab + apples$vMat
```

```{r}
cobb_cost <- translogCostEst(
    cName = "cost",
    yName = "qOut",
    pName = c("pCap", "pLab", "pMat"),
    apples, homPrice = FALSE,
    linear = TRUE
)
```

```{r}
summary(cobb_cost$est)
```

```{r}
gtgazer(
    cobb_cost,
    n_coef = 4,
    coefnames = c("$A$", "$\\alpha_1$", "$\\alpha_2$", "$\\alpha_3$", "$\\alpha_4$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qOut`",
        "- Coefficient associ√© √† la variable `pCap`",
        "- Coefficient associ√© √† la variable `pLab`",
        "- Coefficient associ√© √† la variable `pMat`"
    ),
    title = "**Fonction de co√ªt Cobb Douglass**",
    bg_color = bg_color
)
```



## Fonction de co√ªt Cobb Douglass de court terme

:::{.callout-tip}

## Forme de la fonction
$$
c_i = A x_{i3}^{\alpha_3}\prod_{k=1}^{2} p_{ik}^{\alpha_k}q_i^{\alpha_y} \epsilon_i
$$

:::

```{r}
cobb_cost_ct <- translogCostEst(
    cName = "cost",
    yName = "qOut",
    pName = c("pLab", "pMat"),
    fNames = "pCap",
    apples, homPrice = FALSE,
    linear = TRUE
)
```

```{r}
summary(cobb_cost_ct$est)
```

```{r}
gtgazer(
    cobb_cost_ct,
    n_coef = 4,
    coefnames = c("$A$", "$\\alpha_1$", "$\\alpha_2$", "$\\alpha_3$", "$\\alpha_4$"),
    description = c(
        "- Constante du mod√®le",
        "- Coefficient associ√© √† la variable `qOut`",
        "- Coefficient associ√© √† la variable `pCap`",
        "- Coefficient associ√© √† la variable `pLab`",
        "- Coefficient associ√© √† la variable `pMat`"
    ),
    title = "**Fonction de co√ªt Cobb Douglass de court terme**",
    bg_color = bg_color
)
```

## Fonction de co√ªt Translog

:::{.callout-tip}

## Forme de la fonction

$$
\begin{gathered}ln(c_i) = \alpha + \sum_{k=1}^3 \beta_k ln(p_{ik}) + \alpha_qln(q_i) \\ +\frac{1}{2}\sum_{l=1}^3\sum_{k=1}^3\beta_{kl}ln(p_{ik})ln(p_{il})\frac{1}{2}\alpha_{q}(ln(q_i))^2 \\
+\frac{1}{2}\sum_{k=1}^3\alpha_{kq}ln(p_{ik})ln(q_i)+\epsilon_i
\end{gathered}
$$

:::

```{r}
translog_cost <- translogCostEst(
    cName = "cost",
    yName = "qOut",
    pName = c("pCap", "pLab", "pMat"),
    apples, homPrice = FALSE
)
```

```{r}
summary(translog_cost$est)
```

```{r}
gtgazer(
    translog_cost,
    n_coef = 9,
    coefnames = c("$A$"),
    description = c(
        "- Constante du mod√®le"
    ),
    title = "**Fonction de co√ªt Translog**",
    bg_color = bg_color
)
```



## Others

```{r}
apples <- apples |> mutate(cost = vCap + vLab + vMat)
```

- Avec la fonction de cout on trouve 2.7 -- √† v√©rifier 

$\Rightarrow$ Estimer des fonctions de cout, les rendements d'√©chelle, estimer la fonction CES, la leontieff g√©n√©ralis√©e, calculer le profit des producteurs, lien entre efficacit√©, optimalit√©, v√©rifier h√©t√©rosc√©dasticit√©, mod√®les SFA et DEA potentiellement.

La translog ayant bcp plus de param√®tres, ce ne sera pas forc√©ment la bonne forme fonctionnelle !

Etudier les substitutions entre les facteurs ? Comment faire ? Car la Cobb Douglas ne permet pas de le faire.

```{r}
cobbDouglasCalc(c("qCap", "qLab", "qMat"), apples, coef(cd_prod)[1:4], coefCov = NULL, dataLogged = FALSE)
```

## Infos sur le sujet | ROADMAP
$$
Q = f(QCAP, QLAB, QMAT)\\
$$

il y a aussi les infos sur $C(Q)$


- [ ] Expliquer les diff√©rences de profits entre les producteurs ? Regarder du cot√© des fonctions de profit.

Propri√©t√© de la CD => si la fonction de prod est cobb douglas, alors la fonction de co√ªt l'est aussi.

alpha y => mesure des rendements d'√©chelle...

- [ ] Pour la question 7, o nint√®gre la quantit√© d'inputs comme variable explicative => fonction de cout de court terme

- [ ] Fonction de cout qui int√®gre que la quantit√© de capital ne change pas instantan√©ment


- [ ] Rendements d'√©chelle (somme des exposants) => on peut trouver ces rendements d'√©chelle soit en faisant la fonction de co√ªt, ou la fonction de production. Mais on peut aussi les estimer grace √† une fonction de demande

**DEUX CHOSES ESSENTIELLES**


- Il faut estimer les substitutions entre facteurs
- Les rendements d'√©chelle


Dans la cobb douglas les substitutions entre facteurs il est constant et c'est 1.

Regarder le $\prod$


### Notes sur la translog Cost

On pourrait tt √† fait estimer le syst√®me d'√©quations suivant :

Voir aussi la slide 78 sur la fonction $\ln C$

$$
\begin{cases}
S_1 = \alpha_1 + \sum^3_{i=1} \beta_{1j}\ln p_j + \beta_{1y}\ln y\\
S_2 = \alpha_2 + \sum^3_{i=1} \beta_{2j}\ln p_j + \beta_{2y}\ln y\\
S_3 = \alpha_3 + \sum^3_{i=1} \beta_{3j}\ln p_j + \beta_{3y}\ln y
\end{cases}
$$

Inconv√©nients dans la translog et des formes flexibles : 

Le nombre de param√®tres explose √† cause des effets crois√©s et risque important de collin√©arit√©.

Quand on passe au syst√®me au tableau, on a augment√© √† 3*140 donn√©es (420 observations) et on a un peu moins de param√®tres

- Les entreprises les plus grosses sont les plus productives.


[done üíÖ]{style="color:red;"}